---
title: "Webhooks Package"
description: "Comprehensive webhook handling system for healthcare integrations with secure event processing, retry mechanisms, and HIPAA-compliant data transmission."
---

# Webhooks Package

The webhooks package provides comprehensive webhook handling capabilities for the Waylio healthcare platform. It enables secure integration with external healthcare systems, implements robust event processing with retry mechanisms, and ensures HIPAA-compliant data transmission for sensitive healthcare information.

## Installation

```bash
# Install the webhooks package
pnpm add @repo/webhooks

# Peer dependencies (automatically installed in monorepo)
pnpm add crypto next
```

## Overview

The webhooks package facilitates secure communication between Waylio and external healthcare systems, including EHR systems, insurance providers, pharmacy networks, and third-party healthcare applications. It provides event-driven architecture with reliable delivery, security validation, and comprehensive audit logging.

### Key Features

<CardGroup cols={2}>
<Card title="Secure Event Processing" icon="shield-check">
  HMAC signature verification and encrypted payload handling for secure webhook processing.
</Card>

<Card title="Healthcare Integrations" icon="stethoscope">
  Pre-built integrations for EHR systems, insurance providers, and pharmacy networks.
</Card>

<Card title="Reliable Delivery" icon="refresh">
  Automatic retry mechanisms with exponential backoff and dead letter queue handling.
</Card>

<Card title="HIPAA Compliance" icon="lock">
  Audit logging, data encryption, and compliance features for healthcare data transmission.
</Card>
</CardGroup>

## Webhook Event System

### Core Event Handler

<Tabs>
<Tab title="Webhook Manager">
  **Purpose**: Central webhook management and event processing
  
  ```typescript
  // src/core/webhook-manager.ts
  import crypto from 'crypto';
  import { NextRequest, NextResponse } from 'next/server';
  
  export interface WebhookEvent<T = any> {
    id: string;
    type: WebhookEventType;
    data: T;
    timestamp: string;
    organizationId?: string;
    source: string;
    version: string;
    signature?: string;
  }
  
  export type WebhookEventType = 
    // Patient events
    | 'patient.created' | 'patient.updated' | 'patient.deleted'
    // Appointment events
    | 'appointment.created' | 'appointment.updated' | 'appointment.cancelled' | 'appointment.completed'
    // Prescription events
    | 'prescription.created' | 'prescription.filled' | 'prescription.cancelled' | 'prescription.expired'
    // Lab and imaging events
    | 'lab_result.available' | 'imaging_result.available' | 'test.ordered' | 'test.completed'
    // Payment events
    | 'payment.processed' | 'payment.failed' | 'payment.refunded' | 'insurance.verified'
    // System events
    | 'user.created' | 'user.updated' | 'user.deleted' | 'organization.updated'
    // Integration events
    | 'ehr.sync.completed' | 'ehr.sync.failed' | 'pharmacy.notification' | 'insurance.claim.updated';
  
  export interface WebhookConfig {
    url: string;
    secret: string;
    events: WebhookEventType[];
    active: boolean;
    organizationId?: string;
    retryConfig?: RetryConfig;
    headers?: Record<string, string>;
  }
  
  export interface RetryConfig {
    maxAttempts: number;
    initialDelay: number; // milliseconds
    maxDelay: number; // milliseconds
    backoffMultiplier: number;
  }
  
  export interface WebhookDelivery {
    id: string;
    webhookId: string;
    eventId: string;
    url: string;
    httpStatus?: number;
    response?: string;
    error?: string;
    attempt: number;
    deliveredAt?: Date;
    nextRetryAt?: Date;
    createdAt: Date;
  }
  
  export class HealthcareWebhookManager {
    private webhooks: Map<string, WebhookConfig> = new Map();
    private eventHandlers: Map<WebhookEventType, Array<(event: WebhookEvent) => Promise<void>>> = new Map();
    
    constructor() {
      this.initializeDefaultHandlers();
    }
    
    // Register webhook endpoint
    registerWebhook(id: string, config: WebhookConfig): void {
      this.webhooks.set(id, config);
    }
    
    // Remove webhook endpoint
    unregisterWebhook(id: string): void {
      this.webhooks.delete(id);
    }
    
    // Register event handler
    onEvent(eventType: WebhookEventType, handler: (event: WebhookEvent) => Promise<void>): void {
      if (!this.eventHandlers.has(eventType)) {
        this.eventHandlers.set(eventType, []);
      }
      this.eventHandlers.get(eventType)!.push(handler);
    }
    
    // Process incoming webhook
    async processIncomingWebhook(
      request: NextRequest,
      source: string,
      secret?: string
    ): Promise<NextResponse> {
      try {
        const body = await request.text();
        const signature = request.headers.get('x-webhook-signature') || 
                         request.headers.get('x-hub-signature-256');
        
        // Verify signature if secret is provided
        if (secret && signature) {
          if (!this.verifySignature(body, signature, secret)) {
            return NextResponse.json(
              { error: 'Invalid signature' },
              { status: 401 }
            );
          }
        }
        
        // Parse event
        const event: WebhookEvent = JSON.parse(body);
        
        // Validate event structure
        if (!this.validateEvent(event)) {
          return NextResponse.json(
            { error: 'Invalid event structure' },
            { status: 400 }
          );
        }
        
        // Process event
        await this.handleEvent(event);
        
        // Log successful processing
        await this.logWebhookEvent('incoming', event, {
          source,
          httpStatus: 200,
          processed: true,
        });
        
        return NextResponse.json({ success: true });
      } catch (error) {
        console.error('Webhook processing failed:', error);
        
        await this.logWebhookEvent('incoming', null, {
          source,
          error: error instanceof Error ? error.message : 'Unknown error',
          httpStatus: 500,
          processed: false,
        });
        
        return NextResponse.json(
          { error: 'Webhook processing failed' },
          { status: 500 }
        );
      }
    }
    
    // Send outgoing webhook
    async sendWebhook(event: WebhookEvent): Promise<void> {
      const relevantWebhooks = Array.from(this.webhooks.entries())
        .filter(([_, config]) => 
          config.active && 
          config.events.includes(event.type) &&
          (!config.organizationId || config.organizationId === event.organizationId)
        );
      
      for (const [webhookId, config] of relevantWebhooks) {
        await this.deliverWebhook(webhookId, config, event);
      }
    }
    
    // Deliver webhook with retry logic
    private async deliverWebhook(
      webhookId: string,
      config: WebhookConfig,
      event: WebhookEvent,
      attempt: number = 1
    ): Promise<void> {
      const deliveryId = this.generateDeliveryId();
      const retryConfig = config.retryConfig || this.getDefaultRetryConfig();
      
      try {
        // Prepare payload
        const payload = this.preparePayload(event, config);
        const signature = this.generateSignature(payload, config.secret);
        
        // Send webhook
        const response = await fetch(config.url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Webhook-Signature': signature,
            'X-Webhook-Event': event.type,
            'X-Webhook-ID': event.id,
            'X-Webhook-Timestamp': event.timestamp,
            'User-Agent': 'Waylio-Webhooks/1.0',
            ...config.headers,
          },
          body: payload,
        });
        
        const responseText = await response.text();
        
        // Log delivery
        await this.logDelivery({
          id: deliveryId,
          webhookId,
          eventId: event.id,
          url: config.url,
          httpStatus: response.status,
          response: responseText,
          attempt,
          deliveredAt: response.ok ? new Date() : undefined,
          createdAt: new Date(),
        });
        
        // Handle non-2xx responses
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${responseText}`);
        }
        
        console.log(`Webhook delivered successfully: ${webhookId} -> ${event.type}`);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        
        // Log failed delivery
        await this.logDelivery({
          id: deliveryId,
          webhookId,
          eventId: event.id,
          url: config.url,
          error: errorMessage,
          attempt,
          nextRetryAt: attempt < retryConfig.maxAttempts 
            ? new Date(Date.now() + this.calculateDelay(attempt, retryConfig))
            : undefined,
          createdAt: new Date(),
        });
        
        // Retry if attempts remaining
        if (attempt < retryConfig.maxAttempts) {
          const delay = this.calculateDelay(attempt, retryConfig);
          console.log(`Webhook delivery failed, retrying in ${delay}ms: ${webhookId} -> ${event.type}`);
          
          setTimeout(() => {
            this.deliverWebhook(webhookId, config, event, attempt + 1);
          }, delay);
        } else {
          console.error(`Webhook delivery failed permanently: ${webhookId} -> ${event.type}`, error);
          await this.handleDeadLetter(webhookId, config, event, errorMessage);
        }
      }
    }
    
    // Handle incoming event
    private async handleEvent(event: WebhookEvent): Promise<void> {
      const handlers = this.eventHandlers.get(event.type) || [];
      
      // Execute all handlers for this event type
      await Promise.all(
        handlers.map(async (handler) => {
          try {
            await handler(event);
          } catch (error) {
            console.error(`Event handler failed for ${event.type}:`, error);
          }
        })
      );
    }
    
    // Verify webhook signature
    private verifySignature(payload: string, signature: string, secret: string): boolean {
      try {
        // Support different signature formats
        let expectedSignature: string;
        
        if (signature.startsWith('sha256=')) {
          // GitHub/standard format
          const hash = crypto.createHmac('sha256', secret).update(payload).digest('hex');
          expectedSignature = `sha256=${hash}`;
        } else if (signature.startsWith('v1=')) {
          // Stripe format
          const hash = crypto.createHmac('sha256', secret).update(payload).digest('hex');
          expectedSignature = `v1=${hash}`;
        } else {
          // Raw hash
          expectedSignature = crypto.createHmac('sha256', secret).update(payload).digest('hex');
        }
        
        return crypto.timingSafeEqual(
          Buffer.from(signature),
          Buffer.from(expectedSignature)
        );
      } catch (error) {
        console.error('Signature verification failed:', error);
        return false;
      }
    }
    
    // Generate webhook signature
    private generateSignature(payload: string, secret: string): string {
      const hash = crypto.createHmac('sha256', secret).update(payload).digest('hex');
      return `sha256=${hash}`;
    }
    
    // Validate event structure
    private validateEvent(event: any): event is WebhookEvent {
      return (
        typeof event === 'object' &&
        typeof event.id === 'string' &&
        typeof event.type === 'string' &&
        typeof event.timestamp === 'string' &&
        event.data !== undefined
      );
    }
    
    // Prepare webhook payload
    private preparePayload(event: WebhookEvent, config: WebhookConfig): string {
      // Remove sensitive data based on configuration
      const sanitizedEvent = this.sanitizeEventData(event);
      
      return JSON.stringify(sanitizedEvent, null, 2);
    }
    
    // Sanitize event data for external transmission
    private sanitizeEventData(event: WebhookEvent): WebhookEvent {
      const sanitized = { ...event };
      
      // Remove or encrypt sensitive healthcare data
      if (sanitized.data) {
        sanitized.data = this.sanitizeHealthcareData(sanitized.data);
      }
      
      return sanitized;
    }
    
    // Sanitize healthcare-specific data
    private sanitizeHealthcareData(data: any): any {
      if (!data || typeof data !== 'object') {
        return data;
      }
      
      const sensitiveFields = [
        'ssn', 'socialSecurityNumber', 'dateOfBirth', 'phoneNumber',
        'email', 'address', 'medicalRecordNumber', 'insuranceNumber',
        'diagnosis', 'medications', 'allergies', 'symptoms', 'treatmentNotes'
      ];
      
      const sanitized = { ...data };
      
      for (const field of sensitiveFields) {
        if (sanitized[field]) {
          // Replace with placeholder or remove entirely
          sanitized[field] = '[REDACTED]';
        }
      }
      
      return sanitized;
    }
    
    // Calculate retry delay with exponential backoff
    private calculateDelay(attempt: number, config: RetryConfig): number {
      const delay = config.initialDelay * Math.pow(config.backoffMultiplier, attempt - 1);
      return Math.min(delay, config.maxDelay);
    }
    
    // Get default retry configuration
    private getDefaultRetryConfig(): RetryConfig {
      return {
        maxAttempts: 5,
        initialDelay: 1000, // 1 second
        maxDelay: 300000, // 5 minutes
        backoffMultiplier: 2,
      };
    }
    
    // Handle permanently failed webhooks
    private async handleDeadLetter(
      webhookId: string,
      config: WebhookConfig,
      event: WebhookEvent,
      error: string
    ): Promise<void> {
      // Log to dead letter queue
      console.error('Webhook moved to dead letter queue:', {
        webhookId,
        eventType: event.type,
        eventId: event.id,
        url: config.url,
        error,
      });
      
      // In production, you might want to:
      // - Store in a dead letter queue database table
      // - Send alert to monitoring system
      // - Notify administrators
      // - Disable the webhook if too many failures
    }
    
    // Generate unique delivery ID
    private generateDeliveryId(): string {
      return `delivery_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // Log webhook events for audit
    private async logWebhookEvent(
      direction: 'incoming' | 'outgoing',
      event: WebhookEvent | null,
      metadata: any
    ): Promise<void> {
      const logEntry = {
        timestamp: new Date().toISOString(),
        direction,
        eventType: event?.type,
        eventId: event?.id,
        organizationId: event?.organizationId,
        source: metadata.source,
        httpStatus: metadata.httpStatus,
        processed: metadata.processed,
        error: metadata.error,
      };
      
      // Store audit log (in production, this would go to a database)
      console.log('Webhook audit log:', logEntry);
    }
    
    // Log delivery attempts
    private async logDelivery(delivery: WebhookDelivery): Promise<void> {
      // Store delivery log (in production, this would go to a database)
      console.log('Webhook delivery log:', delivery);
    }
    
    // Initialize default event handlers
    private initializeDefaultHandlers(): void {
      // Patient event handlers
      this.onEvent('patient.created', async (event) => {
        console.log('Patient created:', event.data.id);
        // Sync with EHR systems, update analytics, etc.
      });
      
      this.onEvent('patient.updated', async (event) => {
        console.log('Patient updated:', event.data.id);
        // Sync changes with external systems
      });
      
      // Appointment event handlers
      this.onEvent('appointment.created', async (event) => {
        console.log('Appointment created:', event.data.id);
        // Send confirmation emails, update calendars, etc.
      });
      
      this.onEvent('appointment.cancelled', async (event) => {
        console.log('Appointment cancelled:', event.data.id);
        // Send cancellation notifications, update availability, etc.
      });
      
      // Prescription event handlers
      this.onEvent('prescription.created', async (event) => {
        console.log('Prescription created:', event.data.id);
        // Send to pharmacy, update medication lists, etc.
      });
      
      // Payment event handlers
      this.onEvent('payment.processed', async (event) => {
        console.log('Payment processed:', event.data.id);
        // Update billing records, send receipts, etc.
      });
    }
    
    // Create webhook event
    createEvent<T>(
      type: WebhookEventType,
      data: T,
      organizationId?: string
    ): WebhookEvent<T> {
      return {
        id: `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type,
        data,
        timestamp: new Date().toISOString(),
        organizationId,
        source: 'waylio',
        version: '1.0',
      };
    }
    
    // Emit event (process internally and send to external webhooks)
    async emitEvent<T>(
      type: WebhookEventType,
      data: T,
      organizationId?: string
    ): Promise<void> {
      const event = this.createEvent(type, data, organizationId);
      
      // Handle event internally
      await this.handleEvent(event);
      
      // Send to external webhooks
      await this.sendWebhook(event);
    }
  }
  
  // Singleton instance
  export const webhookManager = new HealthcareWebhookManager();
  ```
</Tab>

<Tab title="Healthcare Integrations">
  **Purpose**: Pre-built integrations for common healthcare systems
  
  ```typescript
  // src/integrations/healthcare-integrations.ts
  import { webhookManager, WebhookEvent } from '../core/webhook-manager';
  
  // EHR Integration
  export class EHRIntegration {
    private ehrEndpoint: string;
    private apiKey: string;
    
    constructor(ehrEndpoint: string, apiKey: string) {
      this.ehrEndpoint = ehrEndpoint;
      this.apiKey = apiKey;
      this.setupWebhooks();
    }
    
    private setupWebhooks(): void {
      // Register EHR webhook
      webhookManager.registerWebhook('ehr-system', {
        url: `${this.ehrEndpoint}/webhooks/waylio`,
        secret: this.apiKey,
        events: [
          'patient.created',
          'patient.updated',
          'appointment.created',
          'appointment.updated',
          'prescription.created',
          'lab_result.available',
        ],
        active: true,
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'X-Integration': 'waylio-ehr',
        },
      });
      
      // Handle incoming EHR events
      webhookManager.onEvent('ehr.sync.completed', async (event) => {
        await this.handleEHRSync(event);
      });
    }
    
    private async handleEHRSync(event: WebhookEvent): Promise<void> {
      console.log('EHR sync completed:', event.data);
      
      // Process synchronized data
      if (event.data.patients) {
        await this.processSyncedPatients(event.data.patients);
      }
      
      if (event.data.appointments) {
        await this.processSyncedAppointments(event.data.appointments);
      }
    }
    
    private async processSyncedPatients(patients: any[]): Promise<void> {
      for (const patient of patients) {
        // Update local patient records
        console.log('Processing synced patient:', patient.id);
      }
    }
    
    private async processSyncedAppointments(appointments: any[]): Promise<void> {
      for (const appointment of appointments) {
        // Update local appointment records
        console.log('Processing synced appointment:', appointment.id);
      }
    }
    
    // Sync patient data to EHR
    async syncPatientToEHR(patientData: any): Promise<void> {
      try {
        const response = await fetch(`${this.ehrEndpoint}/api/patients`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.apiKey}`,
          },
          body: JSON.stringify(patientData),
        });
        
        if (!response.ok) {
          throw new Error(`EHR sync failed: ${response.statusText}`);
        }
        
        console.log('Patient synced to EHR successfully');
      } catch (error) {
        console.error('EHR sync failed:', error);
        throw error;
      }
    }
  }
  
  // Pharmacy Integration
  export class PharmacyIntegration {
    private pharmacyEndpoint: string;
    private apiKey: string;
    
    constructor(pharmacyEndpoint: string, apiKey: string) {
      this.pharmacyEndpoint = pharmacyEndpoint;
      this.apiKey = apiKey;
      this.setupWebhooks();
    }
    
    private setupWebhooks(): void {
      // Register pharmacy webhook
      webhookManager.registerWebhook('pharmacy-system', {
        url: `${this.pharmacyEndpoint}/webhooks/waylio`,
        secret: this.apiKey,
        events: [
          'prescription.created',
          'prescription.cancelled',
        ],
        active: true,
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'X-Integration': 'waylio-pharmacy',
        },
      });
      
      // Handle pharmacy notifications
      webhookManager.onEvent('pharmacy.notification', async (event) => {
        await this.handlePharmacyNotification(event);
      });
    }
    
    private async handlePharmacyNotification(event: WebhookEvent): Promise<void> {
      const { type, prescriptionId, status } = event.data;
      
      switch (type) {
        case 'prescription_filled':
          await this.handlePrescriptionFilled(prescriptionId, event.data);
          break;
        case 'prescription_ready':
          await this.handlePrescriptionReady(prescriptionId, event.data);
          break;
        case 'prescription_delayed':
          await this.handlePrescriptionDelayed(prescriptionId, event.data);
          break;
      }
    }
    
    private async handlePrescriptionFilled(prescriptionId: string, data: any): Promise<void> {
      console.log('Prescription filled:', prescriptionId);
      
      // Update prescription status
      // Send notification to patient
      // Update medical records
      
      // Emit internal event
      await webhookManager.emitEvent('prescription.filled', {
        prescriptionId,
        filledAt: data.filledAt,
        pharmacyId: data.pharmacyId,
      });
    }
    
    private async handlePrescriptionReady(prescriptionId: string, data: any): Promise<void> {
      console.log('Prescription ready for pickup:', prescriptionId);
      
      // Send pickup notification to patient
      // Update prescription status
    }
    
    private async handlePrescriptionDelayed(prescriptionId: string, data: any): Promise<void> {
      console.log('Prescription delayed:', prescriptionId);
      
      // Notify patient and provider about delay
      // Update expected ready date
    }
    
    // Send prescription to pharmacy
    async sendPrescriptionToPharmacy(prescriptionData: any): Promise<void> {
      try {
        const response = await fetch(`${this.pharmacyEndpoint}/api/prescriptions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.apiKey}`,
          },
          body: JSON.stringify(prescriptionData),
        });
        
        if (!response.ok) {
          throw new Error(`Pharmacy submission failed: ${response.statusText}`);
        }
        
        console.log('Prescription sent to pharmacy successfully');
      } catch (error) {
        console.error('Pharmacy submission failed:', error);
        throw error;
      }
    }
  }
  
  // Insurance Integration
  export class InsuranceIntegration {
    private insuranceEndpoint: string;
    private apiKey: string;
    
    constructor(insuranceEndpoint: string, apiKey: string) {
      this.insuranceEndpoint = insuranceEndpoint;
      this.apiKey = apiKey;
      this.setupWebhooks();
    }
    
    private setupWebhooks(): void {
      // Register insurance webhook
      webhookManager.registerWebhook('insurance-system', {
        url: `${this.insuranceEndpoint}/webhooks/waylio`,
        secret: this.apiKey,
        events: [
          'appointment.created',
          'prescription.created',
          'payment.processed',
        ],
        active: true,
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'X-Integration': 'waylio-insurance',
        },
      });
      
      // Handle insurance claim updates
      webhookManager.onEvent('insurance.claim.updated', async (event) => {
        await this.handleClaimUpdate(event);
      });
    }
    
    private async handleClaimUpdate(event: WebhookEvent): Promise<void> {
      const { claimId, status, amount, reason } = event.data;
      
      console.log('Insurance claim updated:', claimId, status);
      
      switch (status) {
        case 'approved':
          await this.handleClaimApproved(claimId, amount);
          break;
        case 'denied':
          await this.handleClaimDenied(claimId, reason);
          break;
        case 'pending':
          await this.handleClaimPending(claimId);
          break;
      }
    }
    
    private async handleClaimApproved(claimId: string, amount: number): Promise<void> {
      console.log('Claim approved:', claimId, amount);
      
      // Update billing records
      // Process payment
      // Notify patient and provider
    }
    
    private async handleClaimDenied(claimId: string, reason: string): Promise<void> {
      console.log('Claim denied:', claimId, reason);
      
      // Update billing records
      // Notify patient and provider
      // Initiate appeal process if applicable
    }
    
    private async handleClaimPending(claimId: string): Promise<void> {
      console.log('Claim pending:', claimId);
      
      // Update status
      // Set follow-up reminders
    }
    
    // Verify insurance coverage
    async verifyInsurance(patientId: string, insuranceInfo: any): Promise<any> {
      try {
        const response = await fetch(`${this.insuranceEndpoint}/api/verify`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.apiKey}`,
          },
          body: JSON.stringify({
            patientId,
            insuranceInfo,
          }),
        });
        
        if (!response.ok) {
          throw new Error(`Insurance verification failed: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        // Emit verification event
        await webhookManager.emitEvent('insurance.verified', {
          patientId,
          verified: result.verified,
          coverage: result.coverage,
          copay: result.copay,
          deductible: result.deductible,
        });
        
        return result;
      } catch (error) {
        console.error('Insurance verification failed:', error);
        throw error;
      }
    }
  }
  
  // Lab Integration
  export class LabIntegration {
    private labEndpoint: string;
    private apiKey: string;
    
    constructor(labEndpoint: string, apiKey: string) {
      this.labEndpoint = labEndpoint;
      this.apiKey = apiKey;
      this.setupWebhooks();
    }
    
    private setupWebhooks(): void {
      // Register lab webhook
      webhookManager.registerWebhook('lab-system', {
        url: `${this.labEndpoint}/webhooks/waylio`,
        secret: this.apiKey,
        events: [
          'test.ordered',
        ],
        active: true,
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'X-Integration': 'waylio-lab',
        },
      });
      
      // Handle lab result notifications
      webhookManager.onEvent('lab_result.available', async (event) => {
        await this.handleLabResult(event);
      });
    }
    
    private async handleLabResult(event: WebhookEvent): Promise<void> {
      const { orderId, patientId, results } = event.data;
      
      console.log('Lab results available:', orderId);
      
      // Update lab order status
      // Notify provider
      // Send results to patient portal
      // Update medical records
      
      // Check for critical values
      const criticalResults = results.filter((result: any) => result.status === 'critical');
      if (criticalResults.length > 0) {
        await this.handleCriticalResults(orderId, patientId, criticalResults);
      }
    }
    
    private async handleCriticalResults(
      orderId: string,
      patientId: string,
      criticalResults: any[]
    ): Promise<void> {
      console.log('Critical lab results detected:', orderId);
      
      // Send urgent notifications
      // Alert provider immediately
      // Flag for immediate review
      
      // Emit critical result event
      await webhookManager.emitEvent('lab_result.critical', {
        orderId,
        patientId,
        criticalResults,
        timestamp: new Date().toISOString(),
      });
    }
    
    // Send lab order
    async sendLabOrder(orderData: any): Promise<void> {
      try {
        const response = await fetch(`${this.labEndpoint}/api/orders`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.apiKey}`,
          },
          body: JSON.stringify(orderData),
        });
        
        if (!response.ok) {
          throw new Error(`Lab order submission failed: ${response.statusText}`);
        }
        
        console.log('Lab order sent successfully');
      } catch (error) {
        console.error('Lab order submission failed:', error);
        throw error;
      }
    }
  }
  
  // Initialize integrations
  export function initializeHealthcareIntegrations(): void {
    // Initialize EHR integration
    if (process.env.EHR_ENDPOINT && process.env.EHR_API_KEY) {
      new EHRIntegration(process.env.EHR_ENDPOINT, process.env.EHR_API_KEY);
    }
    
    // Initialize pharmacy integration
    if (process.env.PHARMACY_ENDPOINT && process.env.PHARMACY_API_KEY) {
      new PharmacyIntegration(process.env.PHARMACY_ENDPOINT, process.env.PHARMACY_API_KEY);
    }
    
    // Initialize insurance integration
    if (process.env.INSURANCE_ENDPOINT && process.env.INSURANCE_API_KEY) {
      new InsuranceIntegration(process.env.INSURANCE_ENDPOINT, process.env.INSURANCE_API_KEY);
    }
    
    // Initialize lab integration
    if (process.env.LAB_ENDPOINT && process.env.LAB_API_KEY) {
      new LabIntegration(process.env.LAB_ENDPOINT, process.env.LAB_API_KEY);
    }
  }
  ```
</Tab>

<Tab title="API Routes">
  **Purpose**: Next.js API routes for webhook endpoints
  
  ```typescript
  // app/api/webhooks/[source]/route.ts
  import { NextRequest, NextResponse } from 'next/server';
  import { webhookManager } from '@repo/webhooks';
  
  // Handle incoming webhooks from various sources
  export async function POST(
    request: NextRequest,
    { params }: { params: { source: string } }
  ) {
    const source = params.source;
    
    // Get webhook secret for the source
    const secret = getWebhookSecret(source);
    
    return webhookManager.processIncomingWebhook(request, source, secret);
  }
  
  function getWebhookSecret(source: string): string | undefined {
    const secrets: Record<string, string | undefined> = {
      'ehr': process.env.EHR_WEBHOOK_SECRET,
      'pharmacy': process.env.PHARMACY_WEBHOOK_SECRET,
      'insurance': process.env.INSURANCE_WEBHOOK_SECRET,
      'lab': process.env.LAB_WEBHOOK_SECRET,
      'stripe': process.env.STRIPE_WEBHOOK_SECRET,
      'clerk': process.env.CLERK_WEBHOOK_SECRET,
    };
    
    return secrets[source];
  }
  
  // app/api/webhooks/test/route.ts
  import { NextRequest, NextResponse } from 'next/server';
  import { webhookManager } from '@repo/webhooks';
  
  // Test webhook endpoint for development
  export async function POST(request: NextRequest) {
    if (process.env.NODE_ENV === 'production') {
      return NextResponse.json({ error: 'Not available in production' }, { status: 404 });
    }
    
    try {
      const body = await request.json();
      
      // Create test event
      const event = webhookManager.createEvent(
        body.type || 'test.event',
        body.data || { message: 'Test webhook event' },
        body.organizationId
      );
      
      // Process event
      await webhookManager.emitEvent(event.type, event.data, event.organizationId);
      
      return NextResponse.json({ success: true, event });
    } catch (error) {
      console.error('Test webhook failed:', error);
      return NextResponse.json(
        { error: 'Test webhook failed' },
        { status: 500 }
      );
    }
  }
  ```
</Tab>
</Tabs>

## React Hooks and Components

### Webhook Management

<AccordionGroup>
<Accordion title="Webhook Status Hook">
  ```typescript
  // src/hooks/use-webhook-status.ts
  import { useState, useEffect } from 'react';
  
  export interface WebhookStatus {
    id: string;
    url: string;
    active: boolean;
    lastDelivery?: Date;
    successRate: number;
    failureCount: number;
    events: string[];
  }
  
  export function useWebhookStatus(organizationId?: string) {
    const [webhooks, setWebhooks] = useState<WebhookStatus[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    
    useEffect(() => {
      fetchWebhookStatus();
    }, [organizationId]);
    
    const fetchWebhookStatus = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/webhooks/status${organizationId ? `?org=${organizationId}` : ''}`);
        
        if (!response.ok) {
          throw new Error('Failed to fetch webhook status');
        }
        
        const data = await response.json();
        setWebhooks(data.webhooks);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };
    
    const testWebhook = async (webhookId: string) => {
      try {
        const response = await fetch(`/api/webhooks/${webhookId}/test`, {
          method: 'POST',
        });
        
        if (!response.ok) {
          throw new Error('Webhook test failed');
        }
        
        await fetchWebhookStatus(); // Refresh status
        return true;
      } catch (err) {
        console.error('Webhook test failed:', err);
        return false;
      }
    };
    
    const toggleWebhook = async (webhookId: string, active: boolean) => {
      try {
        const response = await fetch(`/api/webhooks/${webhookId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ active }),
        });
        
        if (!response.ok) {
          throw new Error('Failed to update webhook');
        }
        
        await fetchWebhookStatus(); // Refresh status
        return true;
      } catch (err) {
        console.error('Failed to update webhook:', err);
        return false;
      }
    };
    
    return {
      webhooks,
      loading,
      error,
      testWebhook,
      toggleWebhook,
      refresh: fetchWebhookStatus,
    };
  }
  ```
</Accordion>

<Accordion title="Webhook Dashboard Component">
  ```typescript
  // src/components/webhook-dashboard.tsx
  import React from 'react';
  import { useWebhookStatus } from '../hooks/use-webhook-status';
  
  interface WebhookDashboardProps {
    organizationId?: string;
  }
  
  export function WebhookDashboard({ organizationId }: WebhookDashboardProps) {
    const { webhooks, loading, error, testWebhook, toggleWebhook, refresh } = 
      useWebhookStatus(organizationId);
    
    if (loading) {
      return (
        <div className="flex items-center justify-center p-8">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
      );
    }
    
    if (error) {
      return (
        <div className="bg-red-50 border border-red-200 rounded-md p-4">
          <p className="text-red-600">Error loading webhooks: {error}</p>
          <button
            onClick={refresh}
            className="mt-2 text-red-600 hover:text-red-800 underline"
          >
            Try again
          </button>
        </div>
      );
    }
    
    return (
      <div className="webhook-dashboard">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-2xl font-bold text-gray-900">Webhook Status</h2>
          <button
            onClick={refresh}
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          >
            Refresh
          </button>
        </div>
        
        {webhooks.length === 0 ? (
          <div className="text-center py-8">
            <p className="text-gray-500">No webhooks configured</p>
          </div>
        ) : (
          <div className="space-y-4">
            {webhooks.map((webhook) => (
              <WebhookCard
                key={webhook.id}
                webhook={webhook}
                onTest={() => testWebhook(webhook.id)}
                onToggle={(active) => toggleWebhook(webhook.id, active)}
              />
            ))}
          </div>
        )}
      </div>
    );
  }
  
  interface WebhookCardProps {
    webhook: any;
    onTest: () => Promise<boolean>;
    onToggle: (active: boolean) => Promise<boolean>;
  }
  
  function WebhookCard({ webhook, onTest, onToggle }: WebhookCardProps) {
    const [testing, setTesting] = useState(false);
    const [toggling, setToggling] = useState(false);
    
    const handleTest = async () => {
      setTesting(true);
      const success = await onTest();
      setTesting(false);
      
      if (success) {
        // Show success message
      }
    };
    
    const handleToggle = async () => {
      setToggling(true);
      await onToggle(!webhook.active);
      setToggling(false);
    };
    
    return (
      <div className="bg-white border border-gray-200 rounded-lg p-6">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center space-x-3">
            <div className={`w-3 h-3 rounded-full ${
              webhook.active ? 'bg-green-500' : 'bg-gray-400'
            }`} />
            <h3 className="text-lg font-medium text-gray-900">
              {webhook.url}
            </h3>
          </div>
          
          <div className="flex items-center space-x-2">
            <button
              onClick={handleTest}
              disabled={testing || !webhook.active}
              className="px-3 py-1 text-sm bg-blue-100 text-blue-700 rounded hover:bg-blue-200 disabled:opacity-50"
            >
              {testing ? 'Testing...' : 'Test'}
            </button>
            
            <button
              onClick={handleToggle}
              disabled={toggling}
              className={`px-3 py-1 text-sm rounded ${
                webhook.active
                  ? 'bg-red-100 text-red-700 hover:bg-red-200'
                  : 'bg-green-100 text-green-700 hover:bg-green-200'
              } disabled:opacity-50`}
            >
              {toggling ? 'Updating...' : webhook.active ? 'Disable' : 'Enable'}
            </button>
          </div>
        </div>
        
        <div className="grid grid-cols-3 gap-4 mb-4">
          <div>
            <p className="text-sm text-gray-500">Success Rate</p>
            <p className="text-lg font-semibold text-gray-900">
              {(webhook.successRate * 100).toFixed(1)}%
            </p>
          </div>
          
          <div>
            <p className="text-sm text-gray-500">Failures</p>
            <p className="text-lg font-semibold text-gray-900">
              {webhook.failureCount}
            </p>
          </div>
          
          <div>
            <p className="text-sm text-gray-500">Last Delivery</p>
            <p className="text-lg font-semibold text-gray-900">
              {webhook.lastDelivery 
                ? new Date(webhook.lastDelivery).toLocaleDateString()
                : 'Never'
              }
            </p>
          </div>
        </div>
        
        <div>
          <p className="text-sm text-gray-500 mb-2">Events</p>
          <div className="flex flex-wrap gap-2">
            {webhook.events.map((event: string) => (
              <span
                key={event}
                className="px-2 py-1 text-xs bg-gray-100 text-gray-700 rounded"
              >
                {event}
              </span>
            ))}
          </div>
        </div>
      </div>
    );
  }
  ```
</Accordion>
</AccordionGroup>

## Development

### Setup and Configuration

<Steps>
<Step title="Environment Variables">
  ```bash
  # Webhook secrets
  EHR_WEBHOOK_SECRET="your-ehr-webhook-secret"
  PHARMACY_WEBHOOK_SECRET="your-pharmacy-webhook-secret"
  INSURANCE_WEBHOOK_SECRET="your-insurance-webhook-secret"
  LAB_WEBHOOK_SECRET="your-lab-webhook-secret"
  
  # Integration endpoints
  EHR_ENDPOINT="https://ehr-system.example.com"
  EHR_API_KEY="your-ehr-api-key"
  PHARMACY_ENDPOINT="https://pharmacy-system.example.com"
  PHARMACY_API_KEY="your-pharmacy-api-key"
  ```
</Step>

<Step title="Webhook Registration">
  ```typescript
  // lib/webhook-setup.ts
  import { webhookManager, initializeHealthcareIntegrations } from '@repo/webhooks';
  
  export function setupWebhooks() {
    // Initialize healthcare integrations
    initializeHealthcareIntegrations();
    
    // Register custom webhooks
    webhookManager.registerWebhook('custom-integration', {
      url: 'https://your-system.com/webhooks',
      secret: 'your-webhook-secret',
      events: ['patient.created', 'appointment.created'],
      active: true,
    });
    
    // Set up event handlers
    webhookManager.onEvent('patient.created', async (event) => {
      console.log('New patient created:', event.data.id);
      // Custom logic here
    });
  }
  ```
</Step>

<Step title="Usage in API Routes">
  ```typescript
  // app/api/patients/route.ts
  import { webhookManager } from '@repo/webhooks';
  
  export async function POST(request: Request) {
    try {
      const patientData = await request.json();
      
      // Create patient
      const patient = await createPatient(patientData);
      
      // Emit webhook event
      await webhookManager.emitEvent('patient.created', patient);
      
      return Response.json({ success: true, patient });
    } catch (error) {
      return Response.json({ error: 'Failed to create patient' }, { status: 500 });
    }
  }
  ```
</Step>
</Steps>

## Best Practices

### Healthcare Webhook Guidelines

<AccordionGroup>
<Accordion title="Security Best Practices">
  - Always verify webhook signatures using HMAC
  - Use HTTPS for all webhook endpoints
  - Implement proper authentication and authorization
  - Sanitize sensitive healthcare data before transmission
  - Log all webhook events for audit compliance
</Accordion>

<Accordion title="Reliability and Performance">
  - Implement exponential backoff for retries
  - Use dead letter queues for permanently failed webhooks
  - Set appropriate timeout values for webhook deliveries
  - Monitor webhook performance and success rates
  - Implement circuit breakers for failing endpoints
</Accordion>

<Accordion title="HIPAA Compliance">
  - Encrypt sensitive data in webhook payloads
  - Maintain comprehensive audit logs
  - Implement proper access controls
  - Regular security assessments of webhook endpoints
  - Ensure business associate agreements with third parties
</Accordion>
</AccordionGroup>

<Note>
Webhook handling in healthcare applications requires strict security and compliance measures. Always ensure proper encryption, authentication, and audit logging for all webhook communications involving PHI.
</Note>
