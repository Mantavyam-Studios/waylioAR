---
title: "Payments Package"
description: "Comprehensive payment processing system powered by Stripe, handling medical billing, insurance claims, and secure healthcare transactions."
---

# Payments Package

The payments package provides secure payment processing for the Waylio platform, built on Stripe. It handles medical billing, insurance claims processing, co-payments, and subscription management while maintaining PCI DSS compliance and healthcare-specific payment workflows.

## Installation

```bash
# Install the payments package
pnpm add @repo/payments

# Peer dependencies (automatically installed in monorepo)
pnpm add stripe @stripe/stripe-js @stripe/react-stripe-js
```

## Overview

The payments package centralizes all payment-related functionality, providing secure, compliant payment processing for healthcare services. It supports multiple payment methods, insurance integration, and automated billing workflows.

### Key Features

<CardGroup cols={2}>
<Card title="Secure Processing" icon="credit-card">
  PCI DSS compliant payment processing with Stripe's secure infrastructure.
</Card>

<Card title="Insurance Integration" icon="shield">
  Automated insurance verification, claims processing, and co-payment calculation.
</Card>

<Card title="Medical Billing" icon="receipt">
  Healthcare-specific billing workflows with CPT codes and insurance claim management.
</Card>

<Card title="Subscription Management" icon="refresh-cw">
  Recurring billing for subscriptions, payment plans, and membership fees.
</Card>
</CardGroup>

## Payment Components

### Stripe Integration

<Tabs>
<Tab title="Payment Provider">
  **Purpose**: Root payment provider with Stripe configuration
  
  ```typescript
  // app/layout.tsx
  import { PaymentProvider } from '@repo/payments';
  import { loadStripe } from '@stripe/stripe-js';
  
  const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY);
  
  export default function RootLayout({
    children,
  }: {
    children: React.ReactNode;
  }) {
    return (
      <html lang="en">
        <body>
          <PaymentProvider stripePromise={stripePromise}>
            {children}
          </PaymentProvider>
        </body>
      </html>
    );
  }
  ```
</Tab>

<Tab title="Payment Form">
  **Purpose**: Secure payment form for medical services
  
  ```typescript
  import {
    PaymentForm,
    CardElement,
    useStripe,
    useElements,
    PaymentMethodSelector,
  } from '@repo/payments';
  import { useState } from 'react';
  
  interface MedicalPaymentFormProps {
    amount: number;
    patientId: string;
    appointmentId?: string;
    insuranceInfo?: {
      providerId: string;
      policyNumber: string;
      groupNumber: string;
      copayAmount: number;
    };
    onPaymentSuccess: (paymentIntent: any) => void;
    onPaymentError: (error: string) => void;
  }
  
  export function MedicalPaymentForm({
    amount,
    patientId,
    appointmentId,
    insuranceInfo,
    onPaymentSuccess,
    onPaymentError,
  }: MedicalPaymentFormProps) {
    const stripe = useStripe();
    const elements = useElements();
    const [processing, setProcessing] = useState(false);
    const [paymentMethod, setPaymentMethod] = useState<'card' | 'insurance' | 'both'>('card');
    
    const handleSubmit = async (event: React.FormEvent) => {
      event.preventDefault();
      
      if (!stripe || !elements) {
        return;
      }
      
      setProcessing(true);
      
      try {
        const cardElement = elements.getElement(CardElement);
        
        if (!cardElement) {
          throw new Error('Card element not found');
        }
        
        // Create payment method
        const { error: methodError, paymentMethod: stripePaymentMethod } = 
          await stripe.createPaymentMethod({
            type: 'card',
            card: cardElement,
            billing_details: {
              name: 'Patient Name', // Get from patient data
            },
          });
        
        if (methodError) {
          throw new Error(methodError.message);
        }
        
        // Process payment with backend
        const response = await fetch('/api/payments/process-medical-payment', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            amount,
            patientId,
            appointmentId,
            paymentMethodId: stripePaymentMethod.id,
            insuranceInfo,
            paymentType: paymentMethod,
          }),
        });
        
        const result = await response.json();
        
        if (!response.ok) {
          throw new Error(result.error || 'Payment failed');
        }
        
        // Confirm payment if required
        if (result.requiresAction) {
          const { error: confirmError } = await stripe.confirmCardPayment(
            result.clientSecret
          );
          
          if (confirmError) {
            throw new Error(confirmError.message);
          }
        }
        
        onPaymentSuccess(result.paymentIntent);
      } catch (error) {
        onPaymentError(error.message);
      } finally {
        setProcessing(false);
      }
    };
    
    return (
      <div className="max-w-md mx-auto">
        <div className="bg-white p-6 rounded-lg shadow-lg">
          <h2 className="text-xl font-semibold mb-4">Payment Information</h2>
          
          {/* Payment Summary */}
          <div className="mb-6 p-4 bg-gray-50 rounded-lg">
            <div className="flex justify-between items-center mb-2">
              <span>Service Amount:</span>
              <span className="font-semibold">${(amount / 100).toFixed(2)}</span>
            </div>
            
            {insuranceInfo && (
              <>
                <div className="flex justify-between items-center mb-2">
                  <span>Insurance Coverage:</span>
                  <span className="text-green-600">
                    -${((amount - insuranceInfo.copayAmount) / 100).toFixed(2)}
                  </span>
                </div>
                <div className="flex justify-between items-center font-semibold border-t pt-2">
                  <span>Your Copay:</span>
                  <span>${(insuranceInfo.copayAmount / 100).toFixed(2)}</span>
                </div>
              </>
            )}
          </div>
          
          {/* Payment Method Selection */}
          <PaymentMethodSelector
            value={paymentMethod}
            onChange={setPaymentMethod}
            hasInsurance={!!insuranceInfo}
            className="mb-6"
          />
          
          {/* Payment Form */}
          <form onSubmit={handleSubmit}>
            {(paymentMethod === 'card' || paymentMethod === 'both') && (
              <div className="mb-6">
                <label className="block text-sm font-medium mb-2">
                  Card Information
                </label>
                <div className="p-3 border border-gray-300 rounded-lg">
                  <CardElement
                    options={{
                      style: {
                        base: {
                          fontSize: '16px',
                          color: '#424770',
                          '::placeholder': {
                            color: '#aab7c4',
                          },
                        },
                      },
                    }}
                  />
                </div>
              </div>
            )}
            
            {insuranceInfo && (paymentMethod === 'insurance' || paymentMethod === 'both') && (
              <div className="mb-6 p-4 bg-blue-50 rounded-lg">
                <h3 className="font-medium mb-2">Insurance Information</h3>
                <div className="text-sm space-y-1">
                  <div>Provider: {insuranceInfo.providerId}</div>
                  <div>Policy: {insuranceInfo.policyNumber}</div>
                  <div>Group: {insuranceInfo.groupNumber}</div>
                </div>
              </div>
            )}
            
            <button
              type="submit"
              disabled={!stripe || processing}
              className="w-full bg-blue-600 text-white py-3 px-4 rounded-lg font-medium disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {processing ? 'Processing...' : `Pay $${(amount / 100).toFixed(2)}`}
            </button>
          </form>
        </div>
      </div>
    );
  }
  ```
</Tab>

<Tab title="Payment History">
  **Purpose**: Display patient payment history and receipts
  
  ```typescript
  import { usePaymentHistory, PaymentStatus } from '@repo/payments';
  import { Card, CardContent, CardHeader, CardTitle, Badge } from '@repo/design-system';
  
  export function PaymentHistory({ patientId }: { patientId: string }) {
    const {
      payments,
      loading,
      error,
      downloadReceipt,
      requestRefund,
    } = usePaymentHistory(patientId);
    
    if (loading) return <div>Loading payment history...</div>;
    if (error) return <div>Error loading payments: {error.message}</div>;
    
    return (
      <div className="space-y-4">
        <h2 className="text-xl font-semibold">Payment History</h2>
        
        {payments.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            No payments found
          </div>
        ) : (
          <div className="space-y-4">
            {payments.map((payment) => (
              <Card key={payment.id}>
                <CardHeader>
                  <div className="flex items-center justify-between">
                    <CardTitle className="text-lg">
                      {payment.description || 'Medical Service'}
                    </CardTitle>
                    <PaymentStatus status={payment.status} />
                  </div>
                </CardHeader>
                
                <CardContent>
                  <div className="grid grid-cols-2 gap-4 mb-4">
                    <div>
                      <span className="text-sm text-gray-600">Amount:</span>
                      <div className="font-semibold">
                        ${(payment.amount / 100).toFixed(2)}
                      </div>
                    </div>
                    
                    <div>
                      <span className="text-sm text-gray-600">Date:</span>
                      <div className="font-semibold">
                        {new Date(payment.created).toLocaleDateString()}
                      </div>
                    </div>
                    
                    <div>
                      <span className="text-sm text-gray-600">Payment Method:</span>
                      <div className="font-semibold">
                        {payment.paymentMethod?.card ? 
                          `**** ${payment.paymentMethod.card.last4}` : 
                          'Insurance'
                        }
                      </div>
                    </div>
                    
                    <div>
                      <span className="text-sm text-gray-600">Reference:</span>
                      <div className="font-mono text-sm">
                        {payment.id.substring(0, 12)}...
                      </div>
                    </div>
                  </div>
                  
                  {payment.appointmentId && (
                    <div className="mb-4">
                      <span className="text-sm text-gray-600">Appointment:</span>
                      <div className="font-semibold">
                        {payment.appointmentDetails?.type} - {payment.appointmentDetails?.providerName}
                      </div>
                    </div>
                  )}
                  
                  <div className="flex gap-2">
                    <button
                      onClick={() => downloadReceipt(payment.id)}
                      className="px-3 py-1 text-sm border border-gray-300 rounded hover:bg-gray-50"
                    >
                      Download Receipt
                    </button>
                    
                    {payment.status === 'succeeded' && payment.refundable && (
                      <button
                        onClick={() => requestRefund(payment.id)}
                        className="px-3 py-1 text-sm text-red-600 border border-red-300 rounded hover:bg-red-50"
                      >
                        Request Refund
                      </button>
                    )}
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        )}
      </div>
    );
  }
  
  function PaymentStatus({ status }: { status: string }) {
    const statusConfig = {
      succeeded: { label: 'Paid', variant: 'default' as const },
      pending: { label: 'Pending', variant: 'secondary' as const },
      failed: { label: 'Failed', variant: 'destructive' as const },
      canceled: { label: 'Canceled', variant: 'outline' as const },
      refunded: { label: 'Refunded', variant: 'outline' as const },
    };
    
    const config = statusConfig[status] || { label: status, variant: 'secondary' as const };
    
    return <Badge variant={config.variant}>{config.label}</Badge>;
  }
  ```
</Tab>
</Tabs>

## Medical Billing

### Insurance Processing

<AccordionGroup>
<Accordion title="Insurance Verification">
  ```typescript
  import { verifyInsurance, calculateCopay } from '@repo/payments';
  
  export class InsuranceProcessor {
    static async verifyPatientInsurance(insuranceData: {
      providerId: string;
      policyNumber: string;
      groupNumber: string;
      patientId: string;
      serviceDate: Date;
    }) {
      try {
        const verification = await verifyInsurance({
          provider: insuranceData.providerId,
          policy: insuranceData.policyNumber,
          group: insuranceData.groupNumber,
          member: insuranceData.patientId,
          serviceDate: insuranceData.serviceDate.toISOString(),
        });
        
        return {
          isActive: verification.active,
          coverageDetails: {
            deductible: verification.deductible,
            deductibleMet: verification.deductibleMet,
            copayAmount: verification.copay,
            coinsuranceRate: verification.coinsurance,
            outOfPocketMax: verification.outOfPocketMax,
            outOfPocketMet: verification.outOfPocketMet,
          },
          benefits: verification.benefits,
          priorAuthRequired: verification.priorAuthRequired,
          effectiveDate: verification.effectiveDate,
          terminationDate: verification.terminationDate,
        };
      } catch (error) {
        throw new Error(`Insurance verification failed: ${error.message}`);
      }
    }
    
    static async calculatePatientResponsibility(
      serviceAmount: number,
      cptCodes: string[],
      insuranceInfo: any
    ) {
      const calculations = await Promise.all(
        cptCodes.map(async (cptCode) => {
          const coverage = await this.getCoverageForService(cptCode, insuranceInfo);
          
          return {
            cptCode,
            serviceAmount: serviceAmount / cptCodes.length, // Distribute evenly
            insuranceCoverage: coverage.coverageAmount,
            patientResponsibility: coverage.patientAmount,
            copay: coverage.copay,
            deductible: coverage.deductible,
            coinsurance: coverage.coinsurance,
          };
        })
      );
      
      const totalPatientResponsibility = calculations.reduce(
        (sum, calc) => sum + calc.patientResponsibility,
        0
      );
      
      return {
        totalAmount: serviceAmount,
        insuranceCoverage: serviceAmount - totalPatientResponsibility,
        patientResponsibility: totalPatientResponsibility,
        breakdown: calculations,
      };
    }
    
    private static async getCoverageForService(cptCode: string, insuranceInfo: any) {
      // Mock implementation - integrate with actual insurance API
      const baseCoverage = 0.8; // 80% coverage
      const copay = 25; // $25 copay
      
      return {
        coverageAmount: Math.floor(insuranceInfo.serviceAmount * baseCoverage),
        patientAmount: Math.floor(insuranceInfo.serviceAmount * (1 - baseCoverage)) + copay,
        copay,
        deductible: 0, // Assume met
        coinsurance: Math.floor(insuranceInfo.serviceAmount * 0.2),
      };
    }
  }
  ```
</Accordion>

<Accordion title="Claims Processing">
  ```typescript
  export class ClaimsProcessor {
    static async submitInsuranceClaim(claimData: {
      patientId: string;
      providerId: string;
      appointmentId: string;
      serviceDate: Date;
      cptCodes: Array<{
        code: string;
        description: string;
        amount: number;
        units: number;
      }>;
      diagnosisCodes: string[];
      insuranceInfo: {
        providerId: string;
        policyNumber: string;
        groupNumber: string;
      };
    }) {
      try {
        // Create claim in Stripe
        const claim = await stripe.claims.create({
          type: 'medical',
          amount: claimData.cptCodes.reduce((sum, cpt) => sum + cpt.amount, 0),
          currency: 'usd',
          metadata: {
            patient_id: claimData.patientId,
            provider_id: claimData.providerId,
            appointment_id: claimData.appointmentId,
            service_date: claimData.serviceDate.toISOString(),
          },
          billing_details: {
            patient: await this.getPatientBillingDetails(claimData.patientId),
            provider: await this.getProviderBillingDetails(claimData.providerId),
          },
          services: claimData.cptCodes.map(cpt => ({
            cpt_code: cpt.code,
            description: cpt.description,
            amount: cpt.amount,
            units: cpt.units,
          })),
          diagnosis_codes: claimData.diagnosisCodes,
          insurance: claimData.insuranceInfo,
        });
        
        // Store claim in database
        await database.insuranceClaim.create({
          data: {
            id: claim.id,
            patientId: claimData.patientId,
            providerId: claimData.providerId,
            appointmentId: claimData.appointmentId,
            amount: claim.amount,
            status: 'submitted',
            submittedAt: new Date(),
            claimData: claimData,
          },
        });
        
        return {
          claimId: claim.id,
          status: 'submitted',
          estimatedProcessingTime: '5-10 business days',
        };
      } catch (error) {
        throw new Error(`Claim submission failed: ${error.message}`);
      }
    }
    
    static async trackClaimStatus(claimId: string) {
      try {
        const claim = await stripe.claims.retrieve(claimId);
        
        // Update database with current status
        await database.insuranceClaim.update({
          where: { id: claimId },
          data: {
            status: claim.status,
            processedAt: claim.processed_at ? new Date(claim.processed_at * 1000) : null,
            paidAmount: claim.amount_paid || 0,
            denialReason: claim.denial_reason,
            updatedAt: new Date(),
          },
        });
        
        return {
          claimId: claim.id,
          status: claim.status,
          submittedAt: new Date(claim.created * 1000),
          processedAt: claim.processed_at ? new Date(claim.processed_at * 1000) : null,
          paidAmount: claim.amount_paid || 0,
          denialReason: claim.denial_reason,
          nextAction: this.getNextAction(claim.status),
        };
      } catch (error) {
        throw new Error(`Failed to track claim: ${error.message}`);
      }
    }
    
    private static getNextAction(status: string): string {
      switch (status) {
        case 'submitted':
          return 'Waiting for insurance review';
        case 'under_review':
          return 'Insurance is processing the claim';
        case 'approved':
          return 'Payment will be processed within 3-5 business days';
        case 'denied':
          return 'Review denial reason and consider appeal';
        case 'paid':
          return 'Claim has been paid';
        default:
          return 'Contact support for status update';
      }
    }
  }
  ```
</Accordion>

<Accordion title="Medical Billing Codes">
  ```typescript
  export class MedicalBillingCodes {
    // Common CPT codes for healthcare services
    static readonly CPT_CODES = {
      // Office visits
      '99213': { description: 'Office visit, established patient, level 3', baseAmount: 15000 }, // $150
      '99214': { description: 'Office visit, established patient, level 4', baseAmount: 20000 }, // $200
      '99215': { description: 'Office visit, established patient, level 5', baseAmount: 25000 }, // $250
      
      // New patient visits
      '99203': { description: 'Office visit, new patient, level 3', baseAmount: 20000 }, // $200
      '99204': { description: 'Office visit, new patient, level 4', baseAmount: 27500 }, // $275
      '99205': { description: 'Office visit, new patient, level 5', baseAmount: 35000 }, // $350
      
      // Preventive care
      '99395': { description: 'Preventive visit, established patient, 18-39 years', baseAmount: 18000 }, // $180
      '99396': { description: 'Preventive visit, established patient, 40-64 years', baseAmount: 20000 }, // $200
      
      // Procedures
      '12001': { description: 'Simple repair of superficial wounds', baseAmount: 8000 }, // $80
      '93000': { description: 'Electrocardiogram, routine ECG', baseAmount: 5000 }, // $50
      '85025': { description: 'Blood count, complete (CBC)', baseAmount: 3000 }, // $30
    };
    
    // ICD-10 diagnosis codes
    static readonly ICD10_CODES = {
      'Z00.00': 'Encounter for general adult medical examination without abnormal findings',
      'I10': 'Essential hypertension',
      'E11.9': 'Type 2 diabetes mellitus without complications',
      'M79.3': 'Panniculitis, unspecified',
      'R50.9': 'Fever, unspecified',
      'J06.9': 'Acute upper respiratory infection, unspecified',
    };
    
    static getCPTCodeInfo(code: string) {
      return this.CPT_CODES[code] || null;
    }
    
    static getICD10Description(code: string) {
      return this.ICD10_CODES[code] || null;
    }
    
    static calculateServiceAmount(cptCodes: string[], modifiers?: string[]) {
      let totalAmount = 0;
      
      cptCodes.forEach(code => {
        const cptInfo = this.getCPTCodeInfo(code);
        if (cptInfo) {
          let amount = cptInfo.baseAmount;
          
          // Apply modifiers if any
          if (modifiers?.includes('25')) {
            // Significant, separately identifiable evaluation and management service
            amount *= 1.1; // 10% increase
          }
          
          totalAmount += amount;
        }
      });
      
      return Math.round(totalAmount);
    }
    
    static validateCPTCode(code: string): boolean {
      return code in this.CPT_CODES;
    }
    
    static validateICD10Code(code: string): boolean {
      return code in this.ICD10_CODES;
    }
  }
  ```
</Accordion>
</AccordionGroup>

## Subscription Management

### Recurring Billing

<Tabs>
<Tab title="Subscription Plans">
  ```typescript
  import { createSubscription, manageSubscription } from '@repo/payments';
  
  export class SubscriptionManager {
    static readonly PLANS = {
      basic: {
        id: 'plan_basic_monthly',
        name: 'Basic Plan',
        price: 2900, // $29/month
        interval: 'month',
        features: [
          'Up to 100 patients',
          'Basic appointment scheduling',
          'Email notifications',
          'Standard support',
        ],
      },
      professional: {
        id: 'plan_pro_monthly',
        name: 'Professional Plan',
        price: 7900, // $79/month
        interval: 'month',
        features: [
          'Up to 1,000 patients',
          'Advanced scheduling',
          'SMS & email notifications',
          'Analytics dashboard',
          'Priority support',
        ],
      },
      enterprise: {
        id: 'plan_enterprise_monthly',
        name: 'Enterprise Plan',
        price: 19900, // $199/month
        interval: 'month',
        features: [
          'Unlimited patients',
          'Full feature access',
          'Custom integrations',
          'Dedicated support',
          'SLA guarantee',
        ],
      },
    };
    
    static async createOrganizationSubscription(
      organizationId: string,
      planId: string,
      paymentMethodId: string
    ) {
      try {
        const plan = Object.values(this.PLANS).find(p => p.id === planId);
        if (!plan) {
          throw new Error('Invalid plan selected');
        }
        
        // Create Stripe subscription
        const subscription = await stripe.subscriptions.create({
          customer: await this.getOrCreateCustomer(organizationId),
          items: [{ price: planId }],
          default_payment_method: paymentMethodId,
          metadata: {
            organization_id: organizationId,
            plan_name: plan.name,
          },
          billing_cycle_anchor: Math.floor(Date.now() / 1000), // Start immediately
        });
        
        // Store subscription in database
        await database.subscription.create({
          data: {
            id: subscription.id,
            organizationId,
            planId,
            status: subscription.status,
            currentPeriodStart: new Date(subscription.current_period_start * 1000),
            currentPeriodEnd: new Date(subscription.current_period_end * 1000),
            amount: plan.price,
            interval: plan.interval,
            createdAt: new Date(),
          },
        });
        
        return {
          subscriptionId: subscription.id,
          status: subscription.status,
          currentPeriodEnd: new Date(subscription.current_period_end * 1000),
          plan: plan,
        };
      } catch (error) {
        throw new Error(`Subscription creation failed: ${error.message}`);
      }
    }
    
    static async updateSubscription(
      subscriptionId: string,
      newPlanId: string
    ) {
      try {
        const subscription = await stripe.subscriptions.retrieve(subscriptionId);
        const newPlan = Object.values(this.PLANS).find(p => p.id === newPlanId);
        
        if (!newPlan) {
          throw new Error('Invalid plan selected');
        }
        
        // Update Stripe subscription
        const updatedSubscription = await stripe.subscriptions.update(subscriptionId, {
          items: [{
            id: subscription.items.data[0].id,
            price: newPlanId,
          }],
          proration_behavior: 'create_prorations',
        });
        
        // Update database
        await database.subscription.update({
          where: { id: subscriptionId },
          data: {
            planId: newPlanId,
            amount: newPlan.price,
            updatedAt: new Date(),
          },
        });
        
        return {
          subscriptionId: updatedSubscription.id,
          status: updatedSubscription.status,
          plan: newPlan,
          prorationAmount: this.calculateProration(subscription, newPlan),
        };
      } catch (error) {
        throw new Error(`Subscription update failed: ${error.message}`);
      }
    }
    
    static async cancelSubscription(
      subscriptionId: string,
      cancelAtPeriodEnd: boolean = true
    ) {
      try {
        const subscription = await stripe.subscriptions.update(subscriptionId, {
          cancel_at_period_end: cancelAtPeriodEnd,
        });
        
        // Update database
        await database.subscription.update({
          where: { id: subscriptionId },
          data: {
            status: cancelAtPeriodEnd ? 'cancel_at_period_end' : 'canceled',
            canceledAt: cancelAtPeriodEnd ? null : new Date(),
            updatedAt: new Date(),
          },
        });
        
        return {
          subscriptionId: subscription.id,
          status: subscription.status,
          cancelAtPeriodEnd,
          periodEnd: new Date(subscription.current_period_end * 1000),
        };
      } catch (error) {
        throw new Error(`Subscription cancellation failed: ${error.message}`);
      }
    }
    
    private static async getOrCreateCustomer(organizationId: string) {
      const organization = await database.organization.findUnique({
        where: { id: organizationId },
      });
      
      if (!organization) {
        throw new Error('Organization not found');
      }
      
      if (organization.stripeCustomerId) {
        return organization.stripeCustomerId;
      }
      
      // Create new Stripe customer
      const customer = await stripe.customers.create({
        name: organization.name,
        metadata: {
          organization_id: organizationId,
        },
      });
      
      // Update organization with customer ID
      await database.organization.update({
        where: { id: organizationId },
        data: { stripeCustomerId: customer.id },
      });
      
      return customer.id;
    }
    
    private static calculateProration(currentSubscription: any, newPlan: any) {
      const currentAmount = currentSubscription.items.data[0].price.unit_amount;
      const newAmount = newPlan.price;
      const remainingDays = Math.ceil(
        (currentSubscription.current_period_end * 1000 - Date.now()) / (1000 * 60 * 60 * 24)
      );
      const totalDays = Math.ceil(
        (currentSubscription.current_period_end - currentSubscription.current_period_start) / (60 * 60 * 24)
      );
      
      const prorationAmount = ((newAmount - currentAmount) * remainingDays) / totalDays;
      return Math.round(prorationAmount);
    }
  }
  ```
</Tab>

<Tab title="Billing Management">
  ```typescript
  import { useBillingManagement } from '@repo/payments';
  
  export function BillingManagement({ organizationId }: { organizationId: string }) {
    const {
      subscription,
      invoices,
      paymentMethods,
      loading,
      updatePaymentMethod,
      downloadInvoice,
      retryPayment,
    } = useBillingManagement(organizationId);
    
    if (loading) return <div>Loading billing information...</div>;
    
    return (
      <div className="space-y-6">
        {/* Current Subscription */}
        <Card>
          <CardHeader>
            <CardTitle>Current Subscription</CardTitle>
          </CardHeader>
          <CardContent>
            {subscription ? (
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div>
                    <h3 className="font-semibold">{subscription.plan.name}</h3>
                    <p className="text-sm text-gray-600">
                      ${(subscription.amount / 100).toFixed(2)}/{subscription.interval}
                    </p>
                  </div>
                  <Badge variant={subscription.status === 'active' ? 'default' : 'secondary'}>
                    {subscription.status}
                  </Badge>
                </div>
                
                <div className="text-sm">
                  <p>Current period: {subscription.currentPeriodStart} - {subscription.currentPeriodEnd}</p>
                  {subscription.cancelAtPeriodEnd && (
                    <p className="text-red-600">
                      Subscription will cancel on {subscription.currentPeriodEnd}
                    </p>
                  )}
                </div>
                
                <div className="flex gap-2">
                  <button className="px-4 py-2 bg-blue-600 text-white rounded-lg">
                    Change Plan
                  </button>
                  <button className="px-4 py-2 border border-gray-300 rounded-lg">
                    Cancel Subscription
                  </button>
                </div>
              </div>
            ) : (
              <div className="text-center py-8">
                <p className="text-gray-600 mb-4">No active subscription</p>
                <button className="px-4 py-2 bg-blue-600 text-white rounded-lg">
                  Choose a Plan
                </button>
              </div>
            )}
          </CardContent>
        </Card>
        
        {/* Payment Methods */}
        <Card>
          <CardHeader>
            <CardTitle>Payment Methods</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-3">
              {paymentMethods.map((method) => (
                <div key={method.id} className="flex items-center justify-between p-3 border rounded-lg">
                  <div className="flex items-center gap-3">
                    <div className="w-8 h-8 bg-gray-100 rounded flex items-center justify-center">
                      {method.card.brand === 'visa' ? 'ðŸ’³' : 'ðŸ’³'}
                    </div>
                    <div>
                      <p className="font-medium">
                        **** **** **** {method.card.last4}
                      </p>
                      <p className="text-sm text-gray-600">
                        Expires {method.card.exp_month}/{method.card.exp_year}
                      </p>
                    </div>
                  </div>
                  
                  <div className="flex items-center gap-2">
                    {method.isDefault && (
                      <Badge variant="outline">Default</Badge>
                    )}
                    <button
                      onClick={() => updatePaymentMethod(method.id)}
                      className="text-sm text-blue-600 hover:text-blue-800"
                    >
                      Edit
                    </button>
                  </div>
                </div>
              ))}
              
              <button className="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg text-gray-600 hover:border-gray-400">
                + Add Payment Method
              </button>
            </div>
          </CardContent>
        </Card>
        
        {/* Invoice History */}
        <Card>
          <CardHeader>
            <CardTitle>Invoice History</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-3">
              {invoices.map((invoice) => (
                <div key={invoice.id} className="flex items-center justify-between p-3 border rounded-lg">
                  <div>
                    <p className="font-medium">
                      Invoice #{invoice.number}
                    </p>
                    <p className="text-sm text-gray-600">
                      {new Date(invoice.created * 1000).toLocaleDateString()} â€¢ 
                      ${(invoice.amount_paid / 100).toFixed(2)}
                    </p>
                  </div>
                  
                  <div className="flex items-center gap-2">
                    <Badge variant={
                      invoice.status === 'paid' ? 'default' :
                      invoice.status === 'open' ? 'secondary' :
                      'destructive'
                    }>
                      {invoice.status}
                    </Badge>
                    
                    <button
                      onClick={() => downloadInvoice(invoice.id)}
                      className="text-sm text-blue-600 hover:text-blue-800"
                    >
                      Download
                    </button>
                    
                    {invoice.status === 'open' && (
                      <button
                        onClick={() => retryPayment(invoice.id)}
                        className="text-sm text-green-600 hover:text-green-800"
                      >
                        Pay Now
                      </button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }
  ```
</Tab>
</Tabs>

## Development

### Setup and Configuration

<Steps>
<Step title="Environment Variables">
  ```bash
  # Stripe configuration
  STRIPE_SECRET_KEY="sk_test_..."
  NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="pk_test_..."
  STRIPE_WEBHOOK_SECRET="whsec_..."
  
  # Optional: Stripe Connect for multi-party payments
  STRIPE_CONNECT_CLIENT_ID="ca_..."
  
  # Insurance API (if using third-party)
  INSURANCE_API_KEY="..."
  INSURANCE_API_URL="https://api.insurance-provider.com"
  ```
</Step>

<Step title="Webhook Handlers">
  ```typescript
  // app/api/webhooks/stripe/route.ts
  import { NextRequest, NextResponse } from 'next/server';
  import { headers } from 'next/headers';
  import Stripe from 'stripe';
  
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
  
  export async function POST(req: NextRequest) {
    const body = await req.text();
    const signature = headers().get('stripe-signature');
    
    let event: Stripe.Event;
    
    try {
      event = stripe.webhooks.constructEvent(
        body,
        signature,
        process.env.STRIPE_WEBHOOK_SECRET
      );
    } catch (error) {
      return NextResponse.json(
        { error: 'Invalid signature' },
        { status: 400 }
      );
    }
    
    try {
      switch (event.type) {
        case 'payment_intent.succeeded':
          await handlePaymentSucceeded(event.data.object);
          break;
          
        case 'payment_intent.payment_failed':
          await handlePaymentFailed(event.data.object);
          break;
          
        case 'invoice.payment_succeeded':
          await handleInvoicePaymentSucceeded(event.data.object);
          break;
          
        case 'customer.subscription.updated':
          await handleSubscriptionUpdated(event.data.object);
          break;
          
        case 'customer.subscription.deleted':
          await handleSubscriptionDeleted(event.data.object);
          break;
          
        default:
          console.log(`Unhandled event type: ${event.type}`);
      }
      
      return NextResponse.json({ received: true });
    } catch (error) {
      console.error('Webhook processing error:', error);
      return NextResponse.json(
        { error: 'Webhook processing failed' },
        { status: 500 }
      );
    }
  }
  
  async function handlePaymentSucceeded(paymentIntent: Stripe.PaymentIntent) {
    // Update payment status in database
    await database.payment.update({
      where: { stripePaymentIntentId: paymentIntent.id },
      data: {
        status: 'succeeded',
        paidAt: new Date(),
      },
    });
    
    // Send confirmation email/notification
    // Update appointment status if applicable
  }
  ```
</Step>

<Step title="Testing Payments">
  ```typescript
  // __tests__/payments.test.ts
  import { processPayment, verifyInsurance } from '@repo/payments';
  
  // Mock Stripe
  jest.mock('stripe');
  
  describe('Payments', () => {
    test('processes medical payment successfully', async () => {
      const paymentData = {
        amount: 15000, // $150
        patientId: 'patient_123',
        appointmentId: 'apt_123',
        paymentMethodId: 'pm_test_card',
      };
      
      const result = await processPayment(paymentData);
      
      expect(result.status).toBe('succeeded');
      expect(result.amount).toBe(15000);
    });
    
    test('verifies insurance coverage', async () => {
      const insuranceData = {
        providerId: 'BCBS',
        policyNumber: '123456789',
        groupNumber: 'GRP001',
        patientId: 'patient_123',
        serviceDate: new Date(),
      };
      
      const verification = await verifyInsurance(insuranceData);
      
      expect(verification.isActive).toBe(true);
      expect(verification.coverageDetails).toBeDefined();
    });
  });
  ```
</Step>
</Steps>

## Best Practices

### Payment Security

<AccordionGroup>
<Accordion title="PCI DSS Compliance">
  - Never store card data directly
  - Use Stripe's secure tokenization
  - Implement proper SSL/TLS encryption
  - Regular security audits and assessments
  - Secure webhook endpoint validation
</Accordion>

<Accordion title="Healthcare Billing">
  - Accurate CPT and ICD-10 coding
  - Proper insurance verification
  - Transparent pricing and billing
  - HIPAA-compliant payment processing
  - Clear refund and dispute policies
</Accordion>

<Accordion title="User Experience">
  - Clear payment flow and confirmation
  - Multiple payment method options
  - Transparent fee structure
  - Easy access to receipts and history
  - Responsive customer support
</Accordion>
</AccordionGroup>

<Note>
The payments package handles sensitive financial and healthcare data. Always prioritize security, compliance, and user trust when implementing payment features.
</Note>
