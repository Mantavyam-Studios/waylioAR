---
title: "Storage Package"
description: "Comprehensive file storage and management system with cloud providers, HIPAA-compliant medical document handling, and secure file operations for healthcare applications."
---

# Storage Package

The storage package provides comprehensive file storage and management capabilities for the Waylio healthcare platform. It supports multiple cloud providers, implements HIPAA-compliant medical document handling, and provides secure file operations with encryption and access controls.

## Installation

```bash
# Install the storage package
pnpm add @repo/storage

# Peer dependencies (automatically installed in monorepo)
pnpm add @aws-sdk/client-s3 @vercel/blob sharp
```

## Overview

The storage package implements healthcare-grade file storage with support for medical documents, images, and other healthcare-related files. It provides automatic encryption, access logging, and compliance features required for handling Protected Health Information (PHI).

### Key Features

<CardGroup cols={2}>
<Card title="Multi-Provider Support" icon="cloud">
  Support for AWS S3, Vercel Blob, and other cloud storage providers with unified API.
</Card>

<Card title="HIPAA Compliance" icon="shield-check">
  Built-in encryption, access logging, and compliance features for medical document storage.
</Card>

<Card title="Medical Document Processing" icon="file-medical">
  Specialized handling for medical images, PDFs, and other healthcare document types.
</Card>

<Card title="Secure Access Control" icon="lock">
  Role-based access controls with audit logging and temporary access URLs.
</Card>
</CardGroup>

## Storage Providers

### Universal Storage Interface

<Tabs>
<Tab title="Storage Manager">
  **Purpose**: Unified interface for multiple storage providers
  
  ```typescript
  // src/core/storage-manager.ts
  import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
  import { put, del, head } from '@vercel/blob';
  import sharp from 'sharp';
  import { encryptionService } from '@repo/security';
  
  export interface StorageConfig {
    provider: 'aws-s3' | 'vercel-blob' | 'local';
    region?: string;
    bucket?: string;
    accessKeyId?: string;
    secretAccessKey?: string;
    endpoint?: string;
    encryption?: {
      enabled: boolean;
      algorithm: 'AES-256-GCM';
    };
  }
  
  export interface FileMetadata {
    id: string;
    filename: string;
    originalName: string;
    mimeType: string;
    size: number;
    path: string;
    url?: string;
    encrypted: boolean;
    uploadedBy: string;
    uploadedAt: Date;
    organizationId?: string;
    patientId?: string;
    providerId?: string;
    documentType?: 'medical_record' | 'prescription' | 'lab_result' | 'imaging' | 'insurance' | 'other';
    tags?: string[];
    expiresAt?: Date;
    accessLevel: 'public' | 'private' | 'restricted';
    hipaaCompliant: boolean;
  }
  
  export interface UploadOptions {
    filename?: string;
    mimeType?: string;
    encrypt?: boolean;
    documentType?: FileMetadata['documentType'];
    patientId?: string;
    providerId?: string;
    organizationId?: string;
    tags?: string[];
    accessLevel?: FileMetadata['accessLevel'];
    expiresAt?: Date;
  }
  
  export interface DownloadOptions {
    userId: string;
    userRole: string;
    purpose?: string;
    temporaryAccess?: boolean;
    expiresIn?: number; // seconds
  }
  
  export abstract class StorageProvider {
    protected config: StorageConfig;
    
    constructor(config: StorageConfig) {
      this.config = config;
    }
    
    abstract upload(buffer: Buffer, metadata: FileMetadata, options?: UploadOptions): Promise<string>;
    abstract download(path: string, options?: DownloadOptions): Promise<Buffer>;
    abstract delete(path: string): Promise<boolean>;
    abstract getMetadata(path: string): Promise<FileMetadata | null>;
    abstract generateSignedUrl(path: string, expiresIn: number): Promise<string>;
    abstract listFiles(prefix?: string, limit?: number): Promise<FileMetadata[]>;
  }
  
  export class HealthcareStorageManager {
    private providers: Map<string, StorageProvider> = new Map();
    private defaultProvider: string;
    
    constructor() {
      this.initializeProviders();
      this.defaultProvider = process.env.DEFAULT_STORAGE_PROVIDER || 'vercel-blob';
    }
    
    private initializeProviders() {
      // Initialize AWS S3 provider
      if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
        this.providers.set('aws-s3', new AWSS3Provider({
          provider: 'aws-s3',
          region: process.env.AWS_REGION || 'us-east-1',
          bucket: process.env.AWS_S3_BUCKET || 'waylio-healthcare-files',
          accessKeyId: process.env.AWS_ACCESS_KEY_ID,
          secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
          encryption: {
            enabled: true,
            algorithm: 'AES-256-GCM',
          },
        }));
      }
      
      // Initialize Vercel Blob provider
      if (process.env.BLOB_READ_WRITE_TOKEN) {
        this.providers.set('vercel-blob', new VercelBlobProvider({
          provider: 'vercel-blob',
          encryption: {
            enabled: true,
            algorithm: 'AES-256-GCM',
          },
        }));
      }
    }
    
    // Upload file with healthcare compliance
    async uploadFile(
      buffer: Buffer,
      options: UploadOptions & {
        uploadedBy: string;
        organizationId?: string;
      }
    ): Promise<FileMetadata> {
      try {
        // Generate unique file ID
        const fileId = this.generateFileId();
        const filename = options.filename || `file-${fileId}`;
        const path = this.generateFilePath(fileId, filename, options);
        
        // Process file if needed (resize images, etc.)
        const processedBuffer = await this.processFile(buffer, options.mimeType);
        
        // Create metadata
        const metadata: FileMetadata = {
          id: fileId,
          filename,
          originalName: options.filename || filename,
          mimeType: options.mimeType || 'application/octet-stream',
          size: processedBuffer.length,
          path,
          encrypted: options.encrypt !== false, // Default to encrypted
          uploadedBy: options.uploadedBy,
          uploadedAt: new Date(),
          organizationId: options.organizationId,
          patientId: options.patientId,
          providerId: options.providerId,
          documentType: options.documentType || 'other',
          tags: options.tags || [],
          expiresAt: options.expiresAt,
          accessLevel: options.accessLevel || 'private',
          hipaaCompliant: this.isHIPAACompliant(options),
        };
        
        // Get storage provider
        const provider = this.getProvider();
        
        // Upload file
        const url = await provider.upload(processedBuffer, metadata, options);
        metadata.url = url;
        
        // Store metadata in database
        await this.storeMetadata(metadata);
        
        // Log upload event for audit
        await this.logFileEvent('upload', metadata, options.uploadedBy);
        
        return metadata;
      } catch (error) {
        console.error('File upload failed:', error);
        throw new Error('Failed to upload file');
      }
    }
    
    // Download file with access control
    async downloadFile(
      fileId: string,
      options: DownloadOptions
    ): Promise<{ buffer: Buffer; metadata: FileMetadata }> {
      try {
        // Get file metadata
        const metadata = await this.getFileMetadata(fileId);
        if (!metadata) {
          throw new Error('File not found');
        }
        
        // Check access permissions
        if (!await this.checkFileAccess(metadata, options)) {
          throw new Error('Access denied');
        }
        
        // Get storage provider
        const provider = this.getProvider();
        
        // Download file
        const buffer = await provider.download(metadata.path, options);
        
        // Decrypt if encrypted
        const decryptedBuffer = metadata.encrypted 
          ? await this.decryptFile(buffer, metadata)
          : buffer;
        
        // Log download event for audit
        await this.logFileEvent('download', metadata, options.userId, {
          purpose: options.purpose,
        });
        
        return { buffer: decryptedBuffer, metadata };
      } catch (error) {
        console.error('File download failed:', error);
        throw error;
      }
    }
    
    // Generate temporary access URL
    async generateTemporaryUrl(
      fileId: string,
      options: DownloadOptions & { expiresIn?: number }
    ): Promise<string> {
      try {
        const metadata = await this.getFileMetadata(fileId);
        if (!metadata) {
          throw new Error('File not found');
        }
        
        // Check access permissions
        if (!await this.checkFileAccess(metadata, options)) {
          throw new Error('Access denied');
        }
        
        const provider = this.getProvider();
        const expiresIn = options.expiresIn || 3600; // 1 hour default
        
        const signedUrl = await provider.generateSignedUrl(metadata.path, expiresIn);
        
        // Log URL generation for audit
        await this.logFileEvent('generate_url', metadata, options.userId, {
          expiresIn,
          purpose: options.purpose,
        });
        
        return signedUrl;
      } catch (error) {
        console.error('Failed to generate temporary URL:', error);
        throw error;
      }
    }
    
    // Delete file
    async deleteFile(fileId: string, deletedBy: string): Promise<boolean> {
      try {
        const metadata = await this.getFileMetadata(fileId);
        if (!metadata) {
          return false;
        }
        
        const provider = this.getProvider();
        const success = await provider.delete(metadata.path);
        
        if (success) {
          // Remove metadata from database
          await this.removeMetadata(fileId);
          
          // Log deletion for audit
          await this.logFileEvent('delete', metadata, deletedBy);
        }
        
        return success;
      } catch (error) {
        console.error('File deletion failed:', error);
        return false;
      }
    }
    
    // List files with filtering
    async listFiles(filters: {
      organizationId?: string;
      patientId?: string;
      providerId?: string;
      documentType?: FileMetadata['documentType'];
      uploadedBy?: string;
      tags?: string[];
      limit?: number;
      offset?: number;
    }): Promise<FileMetadata[]> {
      try {
        // This would typically query the database
        // For now, return mock data
        return [];
      } catch (error) {
        console.error('Failed to list files:', error);
        return [];
      }
    }
    
    // Process file (resize images, validate documents, etc.)
    private async processFile(buffer: Buffer, mimeType?: string): Promise<Buffer> {
      if (!mimeType) return buffer;
      
      // Process images
      if (mimeType.startsWith('image/')) {
        return this.processImage(buffer, mimeType);
      }
      
      // Process PDFs (validate, optimize, etc.)
      if (mimeType === 'application/pdf') {
        return this.processPDF(buffer);
      }
      
      return buffer;
    }
    
    // Process images (resize, optimize, generate thumbnails)
    private async processImage(buffer: Buffer, mimeType: string): Promise<Buffer> {
      try {
        const image = sharp(buffer);
        const metadata = await image.metadata();
        
        // Resize if too large (max 2048px width)
        if (metadata.width && metadata.width > 2048) {
          return image
            .resize(2048, null, { withoutEnlargement: true })
            .jpeg({ quality: 85 })
            .toBuffer();
        }
        
        // Convert to JPEG for better compression
        if (mimeType !== 'image/jpeg') {
          return image
            .jpeg({ quality: 85 })
            .toBuffer();
        }
        
        return buffer;
      } catch (error) {
        console.error('Image processing failed:', error);
        return buffer;
      }
    }
    
    // Process PDF documents
    private async processPDF(buffer: Buffer): Promise<Buffer> {
      // In a real implementation, you might:
      // - Validate PDF structure
      // - Remove metadata for privacy
      // - Optimize file size
      // - Generate thumbnails
      
      return buffer;
    }
    
    // Encrypt file
    private async encryptFile(buffer: Buffer, metadata: FileMetadata): Promise<Buffer> {
      const encrypted = await encryptionService.encryptPHI(
        buffer.toString('base64'),
        {
          patientId: metadata.patientId,
          dataType: 'medical_record',
        }
      );
      
      return Buffer.from(JSON.stringify(encrypted));
    }
    
    // Decrypt file
    private async decryptFile(buffer: Buffer, metadata: FileMetadata): Promise<Buffer> {
      try {
        const encryptedData = JSON.parse(buffer.toString());
        const decrypted = await encryptionService.decryptPHI(encryptedData);
        return Buffer.from(decrypted, 'base64');
      } catch (error) {
        console.error('File decryption failed:', error);
        throw new Error('Failed to decrypt file');
      }
    }
    
    // Check file access permissions
    private async checkFileAccess(
      metadata: FileMetadata,
      options: DownloadOptions
    ): Promise<boolean> {
      // Public files are accessible to everyone
      if (metadata.accessLevel === 'public') {
        return true;
      }
      
      // Check if file has expired
      if (metadata.expiresAt && metadata.expiresAt < new Date()) {
        return false;
      }
      
      // Check organization access
      if (metadata.organizationId && options.userId) {
        // In a real implementation, check if user belongs to organization
        return true;
      }
      
      // Check patient access (patients can access their own files)
      if (metadata.patientId === options.userId) {
        return true;
      }
      
      // Check provider access
      if (metadata.providerId === options.userId) {
        return true;
      }
      
      // Check role-based access
      if (options.userRole === 'admin') {
        return true;
      }
      
      return false;
    }
    
    // Generate unique file ID
    private generateFileId(): string {
      return `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // Generate file path
    private generateFilePath(
      fileId: string,
      filename: string,
      options: UploadOptions
    ): string {
      const date = new Date();
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      
      let basePath = `${year}/${month}/${day}`;
      
      // Add organization/patient context
      if (options.organizationId) {
        basePath = `orgs/${options.organizationId}/${basePath}`;
      }
      
      if (options.patientId) {
        basePath = `${basePath}/patients/${options.patientId}`;
      }
      
      // Add document type
      if (options.documentType) {
        basePath = `${basePath}/${options.documentType}`;
      }
      
      return `${basePath}/${fileId}/${filename}`;
    }
    
    // Check if upload is HIPAA compliant
    private isHIPAACompliant(options: UploadOptions): boolean {
      return !!(
        options.encrypt !== false && // Must be encrypted
        (options.patientId || options.organizationId) && // Must have context
        options.documentType && // Must have document type
        options.accessLevel !== 'public' // Cannot be public
      );
    }
    
    // Get storage provider
    private getProvider(providerName?: string): StorageProvider {
      const name = providerName || this.defaultProvider;
      const provider = this.providers.get(name);
      
      if (!provider) {
        throw new Error(`Storage provider ${name} not found`);
      }
      
      return provider;
    }
    
    // Store file metadata (would use database in real implementation)
    private async storeMetadata(metadata: FileMetadata): Promise<void> {
      // Store in database
      console.log('Storing metadata:', metadata.id);
    }
    
    // Get file metadata (would use database in real implementation)
    private async getFileMetadata(fileId: string): Promise<FileMetadata | null> {
      // Get from database
      return null;
    }
    
    // Remove file metadata (would use database in real implementation)
    private async removeMetadata(fileId: string): Promise<void> {
      // Remove from database
      console.log('Removing metadata:', fileId);
    }
    
    // Log file events for audit
    private async logFileEvent(
      event: 'upload' | 'download' | 'delete' | 'generate_url',
      metadata: FileMetadata,
      userId: string,
      context?: any
    ): Promise<void> {
      const logEntry = {
        timestamp: new Date().toISOString(),
        event,
        fileId: metadata.id,
        filename: metadata.filename,
        userId,
        organizationId: metadata.organizationId,
        patientId: metadata.patientId,
        documentType: metadata.documentType,
        hipaaCompliant: metadata.hipaaCompliant,
        context,
      };
      
      // Store audit log
      console.log('File audit log:', logEntry);
    }
  }
  
  // Singleton instance
  export const storageManager = new HealthcareStorageManager();
  ```
</Tab>

<Tab title="AWS S3 Provider">
  **Purpose**: AWS S3 storage provider implementation
  
  ```typescript
  // src/providers/aws-s3-provider.ts
  import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand, HeadObjectCommand } from '@aws-sdk/client-s3';
  import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
  import { StorageProvider, StorageConfig, FileMetadata, UploadOptions, DownloadOptions } from '../core/storage-manager';
  
  export class AWSS3Provider extends StorageProvider {
    private s3Client: S3Client;
    private bucket: string;
    
    constructor(config: StorageConfig) {
      super(config);
      
      this.s3Client = new S3Client({
        region: config.region,
        credentials: {
          accessKeyId: config.accessKeyId!,
          secretAccessKey: config.secretAccessKey!,
        },
        endpoint: config.endpoint,
      });
      
      this.bucket = config.bucket!;
    }
    
    async upload(buffer: Buffer, metadata: FileMetadata, options?: UploadOptions): Promise<string> {
      try {
        const command = new PutObjectCommand({
          Bucket: this.bucket,
          Key: metadata.path,
          Body: buffer,
          ContentType: metadata.mimeType,
          ContentLength: buffer.length,
          Metadata: {
            'file-id': metadata.id,
            'original-name': metadata.originalName,
            'uploaded-by': metadata.uploadedBy,
            'organization-id': metadata.organizationId || '',
            'patient-id': metadata.patientId || '',
            'document-type': metadata.documentType || '',
            'hipaa-compliant': metadata.hipaaCompliant.toString(),
          },
          ServerSideEncryption: 'AES256',
          StorageClass: 'STANDARD_IA', // Infrequent Access for cost optimization
        });
        
        await this.s3Client.send(command);
        
        return `https://${this.bucket}.s3.${this.config.region}.amazonaws.com/${metadata.path}`;
      } catch (error) {
        console.error('S3 upload failed:', error);
        throw new Error('Failed to upload to S3');
      }
    }
    
    async download(path: string, options?: DownloadOptions): Promise<Buffer> {
      try {
        const command = new GetObjectCommand({
          Bucket: this.bucket,
          Key: path,
        });
        
        const response = await this.s3Client.send(command);
        
        if (!response.Body) {
          throw new Error('No file content received');
        }
        
        // Convert stream to buffer
        const chunks: Uint8Array[] = [];
        const reader = response.Body.transformToWebStream().getReader();
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(value);
        }
        
        return Buffer.concat(chunks);
      } catch (error) {
        console.error('S3 download failed:', error);
        throw new Error('Failed to download from S3');
      }
    }
    
    async delete(path: string): Promise<boolean> {
      try {
        const command = new DeleteObjectCommand({
          Bucket: this.bucket,
          Key: path,
        });
        
        await this.s3Client.send(command);
        return true;
      } catch (error) {
        console.error('S3 delete failed:', error);
        return false;
      }
    }
    
    async getMetadata(path: string): Promise<FileMetadata | null> {
      try {
        const command = new HeadObjectCommand({
          Bucket: this.bucket,
          Key: path,
        });
        
        const response = await this.s3Client.send(command);
        
        if (!response.Metadata) {
          return null;
        }
        
        return {
          id: response.Metadata['file-id'] || '',
          filename: path.split('/').pop() || '',
          originalName: response.Metadata['original-name'] || '',
          mimeType: response.ContentType || 'application/octet-stream',
          size: response.ContentLength || 0,
          path,
          encrypted: true,
          uploadedBy: response.Metadata['uploaded-by'] || '',
          uploadedAt: response.LastModified || new Date(),
          organizationId: response.Metadata['organization-id'] || undefined,
          patientId: response.Metadata['patient-id'] || undefined,
          documentType: (response.Metadata['document-type'] as any) || 'other',
          accessLevel: 'private',
          hipaaCompliant: response.Metadata['hipaa-compliant'] === 'true',
        };
      } catch (error) {
        console.error('S3 metadata retrieval failed:', error);
        return null;
      }
    }
    
    async generateSignedUrl(path: string, expiresIn: number): Promise<string> {
      try {
        const command = new GetObjectCommand({
          Bucket: this.bucket,
          Key: path,
        });
        
        return await getSignedUrl(this.s3Client, command, { expiresIn });
      } catch (error) {
        console.error('S3 signed URL generation failed:', error);
        throw new Error('Failed to generate signed URL');
      }
    }
    
    async listFiles(prefix?: string, limit?: number): Promise<FileMetadata[]> {
      // Implementation would use ListObjectsV2Command
      return [];
    }
  }
  ```
</Tab>

<Tab title="Vercel Blob Provider">
  **Purpose**: Vercel Blob storage provider implementation
  
  ```typescript
  // src/providers/vercel-blob-provider.ts
  import { put, del, head, list } from '@vercel/blob';
  import { StorageProvider, StorageConfig, FileMetadata, UploadOptions, DownloadOptions } from '../core/storage-manager';
  
  export class VercelBlobProvider extends StorageProvider {
    constructor(config: StorageConfig) {
      super(config);
    }
    
    async upload(buffer: Buffer, metadata: FileMetadata, options?: UploadOptions): Promise<string> {
      try {
        const blob = await put(metadata.path, buffer, {
          access: metadata.accessLevel === 'public' ? 'public' : 'private',
          contentType: metadata.mimeType,
          addRandomSuffix: false,
        });
        
        return blob.url;
      } catch (error) {
        console.error('Vercel Blob upload failed:', error);
        throw new Error('Failed to upload to Vercel Blob');
      }
    }
    
    async download(path: string, options?: DownloadOptions): Promise<Buffer> {
      try {
        // Construct the full URL
        const url = `${process.env.BLOB_STORE_URL}/${path}`;
        
        const response = await fetch(url, {
          headers: {
            'Authorization': `Bearer ${process.env.BLOB_READ_WRITE_TOKEN}`,
          },
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const arrayBuffer = await response.arrayBuffer();
        return Buffer.from(arrayBuffer);
      } catch (error) {
        console.error('Vercel Blob download failed:', error);
        throw new Error('Failed to download from Vercel Blob');
      }
    }
    
    async delete(path: string): Promise<boolean> {
      try {
        await del(path);
        return true;
      } catch (error) {
        console.error('Vercel Blob delete failed:', error);
        return false;
      }
    }
    
    async getMetadata(path: string): Promise<FileMetadata | null> {
      try {
        const result = await head(path);
        
        return {
          id: path.split('/').pop() || '',
          filename: path.split('/').pop() || '',
          originalName: path.split('/').pop() || '',
          mimeType: result.contentType || 'application/octet-stream',
          size: result.size,
          path,
          url: result.url,
          encrypted: true,
          uploadedBy: '',
          uploadedAt: result.uploadedAt,
          accessLevel: 'private',
          hipaaCompliant: true,
        };
      } catch (error) {
        console.error('Vercel Blob metadata retrieval failed:', error);
        return null;
      }
    }
    
    async generateSignedUrl(path: string, expiresIn: number): Promise<string> {
      // Vercel Blob handles signed URLs automatically
      const metadata = await this.getMetadata(path);
      return metadata?.url || '';
    }
    
    async listFiles(prefix?: string, limit?: number): Promise<FileMetadata[]> {
      try {
        const { blobs } = await list({
          prefix,
          limit,
        });
        
        return blobs.map(blob => ({
          id: blob.pathname.split('/').pop() || '',
          filename: blob.pathname.split('/').pop() || '',
          originalName: blob.pathname.split('/').pop() || '',
          mimeType: blob.contentType || 'application/octet-stream',
          size: blob.size,
          path: blob.pathname,
          url: blob.url,
          encrypted: true,
          uploadedBy: '',
          uploadedAt: blob.uploadedAt,
          accessLevel: 'private',
          hipaaCompliant: true,
        }));
      } catch (error) {
        console.error('Vercel Blob list failed:', error);
        return [];
      }
    }
  }
  ```
</Tab>
</Tabs>

## React Hooks and Components

### File Upload Components

<AccordionGroup>
<Accordion title="File Upload Hook">
  ```typescript
  // src/hooks/use-file-upload.ts
  import { useState, useCallback } from 'react';
  import { storageManager, FileMetadata, UploadOptions } from '../core/storage-manager';
  
  export interface UploadState {
    uploading: boolean;
    progress: number;
    error: string | null;
    uploadedFiles: FileMetadata[];
  }
  
  export function useFileUpload() {
    const [state, setState] = useState<UploadState>({
      uploading: false,
      progress: 0,
      error: null,
      uploadedFiles: [],
    });
    
    const uploadFile = useCallback(async (
      file: File,
      options: UploadOptions & { uploadedBy: string }
    ): Promise<FileMetadata | null> => {
      setState(prev => ({
        ...prev,
        uploading: true,
        progress: 0,
        error: null,
      }));
      
      try {
        // Convert file to buffer
        const buffer = Buffer.from(await file.arrayBuffer());
        
        // Upload with progress simulation
        const progressInterval = setInterval(() => {
          setState(prev => ({
            ...prev,
            progress: Math.min(prev.progress + 10, 90),
          }));
        }, 100);
        
        const metadata = await storageManager.uploadFile(buffer, {
          ...options,
          filename: file.name,
          mimeType: file.type,
        });
        
        clearInterval(progressInterval);
        
        setState(prev => ({
          ...prev,
          uploading: false,
          progress: 100,
          uploadedFiles: [...prev.uploadedFiles, metadata],
        }));
        
        return metadata;
      } catch (error) {
        setState(prev => ({
          ...prev,
          uploading: false,
          progress: 0,
          error: error instanceof Error ? error.message : 'Upload failed',
        }));
        
        return null;
      }
    }, []);
    
    const uploadMultipleFiles = useCallback(async (
      files: File[],
      options: UploadOptions & { uploadedBy: string }
    ): Promise<FileMetadata[]> => {
      const results: FileMetadata[] = [];
      
      for (const file of files) {
        const result = await uploadFile(file, options);
        if (result) {
          results.push(result);
        }
      }
      
      return results;
    }, [uploadFile]);
    
    const reset = useCallback(() => {
      setState({
        uploading: false,
        progress: 0,
        error: null,
        uploadedFiles: [],
      });
    }, []);
    
    return {
      ...state,
      uploadFile,
      uploadMultipleFiles,
      reset,
    };
  }
  
  // Hook for medical document upload
  export function useMedicalDocumentUpload(patientId: string, providerId: string) {
    const fileUpload = useFileUpload();
    
    const uploadMedicalDocument = useCallback(async (
      file: File,
      documentType: FileMetadata['documentType'],
      uploadedBy: string
    ) => {
      return fileUpload.uploadFile(file, {
        uploadedBy,
        patientId,
        providerId,
        documentType,
        accessLevel: 'restricted',
        encrypt: true,
        hipaaCompliant: true,
      });
    }, [fileUpload, patientId, providerId]);
    
    return {
      ...fileUpload,
      uploadMedicalDocument,
    };
  }
  ```
</Accordion>

<Accordion title="File Upload Component">
  ```typescript
  // src/components/file-upload.tsx
  import React, { useCallback, useState } from 'react';
  import { useDropzone } from 'react-dropzone';
  import { useMedicalDocumentUpload } from '../hooks/use-file-upload';
  import { FileMetadata } from '../core/storage-manager';
  
  interface MedicalDocumentUploadProps {
    patientId: string;
    providerId: string;
    uploadedBy: string;
    documentType: FileMetadata['documentType'];
    acceptedFileTypes?: string[];
    maxFileSize?: number;
    onUploadComplete?: (files: FileMetadata[]) => void;
    onUploadError?: (error: string) => void;
  }
  
  export function MedicalDocumentUpload({
    patientId,
    providerId,
    uploadedBy,
    documentType,
    acceptedFileTypes = ['.pdf', '.jpg', '.jpeg', '.png', '.dcm'],
    maxFileSize = 10 * 1024 * 1024, // 10MB
    onUploadComplete,
    onUploadError,
  }: MedicalDocumentUploadProps) {
    const { uploadMedicalDocument, uploading, progress, error, uploadedFiles } = 
      useMedicalDocumentUpload(patientId, providerId);
    
    const onDrop = useCallback(async (acceptedFiles: File[]) => {
      const results: FileMetadata[] = [];
      
      for (const file of acceptedFiles) {
        const result = await uploadMedicalDocument(file, documentType, uploadedBy);
        if (result) {
          results.push(result);
        }
      }
      
      if (results.length > 0 && onUploadComplete) {
        onUploadComplete(results);
      }
      
      if (error && onUploadError) {
        onUploadError(error);
      }
    }, [uploadMedicalDocument, documentType, uploadedBy, onUploadComplete, onUploadError, error]);
    
    const { getRootProps, getInputProps, isDragActive } = useDropzone({
      onDrop,
      accept: acceptedFileTypes.reduce((acc, type) => {
        acc[type] = [];
        return acc;
      }, {} as Record<string, string[]>),
      maxSize: maxFileSize,
      multiple: true,
    });
    
    return (
      <div className="medical-document-upload">
        <div
          {...getRootProps()}
          className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors ${
            isDragActive
              ? 'border-blue-400 bg-blue-50'
              : 'border-gray-300 hover:border-gray-400'
          }`}
        >
          <input {...getInputProps()} />
          
          <div className="space-y-2">
            <svg
              className="mx-auto h-12 w-12 text-gray-400"
              stroke="currentColor"
              fill="none"
              viewBox="0 0 48 48"
            >
              <path
                d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02"
                strokeWidth={2}
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            </svg>
            
            <div>
              <p className="text-sm text-gray-600">
                {isDragActive
                  ? 'Drop the files here...'
                  : 'Drag and drop files here, or click to select'}
              </p>
              <p className="text-xs text-gray-500">
                Supported formats: {acceptedFileTypes.join(', ')} (max {Math.round(maxFileSize / 1024 / 1024)}MB)
              </p>
            </div>
          </div>
        </div>
        
        {uploading && (
          <div className="mt-4">
            <div className="flex items-center justify-between text-sm text-gray-600">
              <span>Uploading...</span>
              <span>{progress}%</span>
            </div>
            <div className="mt-1 bg-gray-200 rounded-full h-2">
              <div
                className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                style={{ width: `${progress}%` }}
              />
            </div>
          </div>
        )}
        
        {error && (
          <div className="mt-4 p-3 bg-red-50 border border-red-200 rounded-md">
            <p className="text-sm text-red-600">{error}</p>
          </div>
        )}
        
        {uploadedFiles.length > 0 && (
          <div className="mt-4">
            <h4 className="text-sm font-medium text-gray-900 mb-2">
              Uploaded Files ({uploadedFiles.length})
            </h4>
            <div className="space-y-2">
              {uploadedFiles.map((file) => (
                <div
                  key={file.id}
                  className="flex items-center justify-between p-2 bg-green-50 border border-green-200 rounded-md"
                >
                  <div className="flex items-center space-x-2">
                    <svg
                      className="h-4 w-4 text-green-500"
                      fill="currentColor"
                      viewBox="0 0 20 20"
                    >
                      <path
                        fillRule="evenodd"
                        d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                        clipRule="evenodd"
                      />
                    </svg>
                    <span className="text-sm text-gray-900">{file.originalName}</span>
                  </div>
                  <span className="text-xs text-gray-500">
                    {Math.round(file.size / 1024)} KB
                  </span>
                </div>
              ))}
            </div>
          </div>
        )}
        
        <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-md">
          <div className="flex">
            <svg
              className="h-5 w-5 text-yellow-400"
              viewBox="0 0 20 20"
              fill="currentColor"
            >
              <path
                fillRule="evenodd"
                d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
                clipRule="evenodd"
              />
            </svg>
            <div className="ml-3">
              <p className="text-sm text-yellow-700">
                <strong>HIPAA Notice:</strong> All uploaded files are encrypted and stored securely in compliance with HIPAA regulations. Access is logged and monitored.
              </p>
            </div>
          </div>
        </div>
      </div>
    );
  }
  ```
</Accordion>
</AccordionGroup>

## Development

### Setup and Configuration

<Steps>
<Step title="Environment Variables">
  ```bash
  # Storage configuration
  DEFAULT_STORAGE_PROVIDER="vercel-blob"
  
  # AWS S3 configuration
  AWS_ACCESS_KEY_ID="your-access-key"
  AWS_SECRET_ACCESS_KEY="your-secret-key"
  AWS_REGION="us-east-1"
  AWS_S3_BUCKET="waylio-healthcare-files"
  
  # Vercel Blob configuration
  BLOB_READ_WRITE_TOKEN="your-blob-token"
  BLOB_STORE_URL="https://your-blob-store.vercel-storage.com"
  ```
</Step>

<Step title="File Upload API Route">
  ```typescript
  // app/api/files/upload/route.ts
  import { NextRequest, NextResponse } from 'next/server';
  import { storageManager } from '@repo/storage';
  import { auth } from '@repo/auth';
  
  export async function POST(request: NextRequest) {
    try {
      const { user } = await auth();
      if (!user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }
      
      const formData = await request.formData();
      const file = formData.get('file') as File;
      const documentType = formData.get('documentType') as string;
      const patientId = formData.get('patientId') as string;
      
      if (!file) {
        return NextResponse.json({ error: 'No file provided' }, { status: 400 });
      }
      
      const buffer = Buffer.from(await file.arrayBuffer());
      
      const metadata = await storageManager.uploadFile(buffer, {
        filename: file.name,
        mimeType: file.type,
        uploadedBy: user.id,
        patientId,
        documentType: documentType as any,
        organizationId: user.organizationMemberships?.[0]?.organization?.id,
      });
      
      return NextResponse.json({ success: true, file: metadata });
    } catch (error) {
      console.error('File upload failed:', error);
      return NextResponse.json(
        { error: 'Upload failed' },
        { status: 500 }
      );
    }
  }
  ```
</Step>

<Step title="File Download API Route">
  ```typescript
  // app/api/files/[fileId]/route.ts
  import { NextRequest, NextResponse } from 'next/server';
  import { storageManager } from '@repo/storage';
  import { auth } from '@repo/auth';
  
  export async function GET(
    request: NextRequest,
    { params }: { params: { fileId: string } }
  ) {
    try {
      const { user } = await auth();
      if (!user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }
      
      const { buffer, metadata } = await storageManager.downloadFile(
        params.fileId,
        {
          userId: user.id,
          userRole: user.publicMetadata?.role as string,
          purpose: 'file_download',
        }
      );
      
      return new NextResponse(buffer, {
        headers: {
          'Content-Type': metadata.mimeType,
          'Content-Disposition': `attachment; filename="${metadata.originalName}"`,
          'Content-Length': buffer.length.toString(),
        },
      });
    } catch (error) {
      console.error('File download failed:', error);
      return NextResponse.json(
        { error: 'Download failed' },
        { status: 500 }
      );
    }
  }
  ```
</Step>
</Steps>

## Best Practices

### Healthcare Storage Guidelines

<AccordionGroup>
<Accordion title="HIPAA Compliance">
  - Always encrypt files containing PHI
  - Implement comprehensive access logging
  - Use role-based access controls
  - Regular security audits and compliance checks
  - Secure file deletion and data retention policies
</Accordion>

<Accordion title="Performance Optimization">
  - Use appropriate storage classes for cost optimization
  - Implement file compression for large documents
  - Generate thumbnails for images
  - Use CDN for frequently accessed files
  - Implement caching strategies for metadata
</Accordion>

<Accordion title="Security Best Practices">
  - Validate file types and content
  - Scan files for malware
  - Use signed URLs for temporary access
  - Implement rate limiting for uploads/downloads
  - Regular backup and disaster recovery testing
</Accordion>
</AccordionGroup>

<Note>
File storage in healthcare applications requires strict compliance with HIPAA regulations. Always ensure proper encryption, access controls, and audit logging for all file operations involving PHI.
</Note>
